var myvar : int := 4 * 5;
var other : int := 4 + 5 * myvar;

var b : boolean := true;
var cd : boolean := false;
var d : int := 0;
var e : bool := b;

var test := false;

const wert : int := 3;

var ef : int := 4;
e := true;

if (e) {
	var e : int := 4;
	e := 2;
} else if (e) {
} else {
	if (b) {}
}

var c0 : boolean := false;
var d_ : int := 5;

var A := (dot 0) {
	5 5 5 . .
	4 3 2 . .
	1 . . . .
	1 2 3 4 5
};

var B := int (dot 3) {
	2 . 4  5
	2 . 4  5
	2 . 45 5
	2 . 4  5
	2 . 4  5
};

var J : (1 ° 1) := int {
	1
};

var HGF : (1 ° 1) := J;
var HGF2 : (1 ° 1) := J * J;

var L : (4 ° 5) := B^T;
const zzf : boolean := !(A ~ A);

var c : int := A[1, 2^2];
var fgh : int;
A[1,1] := 0;

if (2 > 2) {}

if (B*A == B*A) {}
if (A == 2*A) {}

var b1 : boolean := A == A && 2 == 2;
var c1 : boolean := b == b;

if (b == true) {}

var C : (2 ° 3) := {
	1 2 3
	4 5 6
};

var tern := 3 == 3 ? 4 : 1 == 2 ? 4 : 5;

var identity := init (var i..10, var j..10) ~> i == j ? 1 : 0;
var zero := init (var i..10, var j..10) ~> 0;
var D_init := init (var i..2, var j..3) ~> (i*j);

var Q : (2 ° 2) := {
	1 2 3
	4 5 3
} * {
	1 2
	2 3
	1 1
};

var Z : (2 ° 3) := {
	1 2 3
	2 3 4
} * {
	1 2 3
	1 2 3
	1 2 3
};

var D : (4 ° 4) := A * B;
var E : (5 ° 5) := B * A;

E := -E;

var g : (2 ° 3) := 5 * C + 4 * C;
var h : int := (5 * 4)^0;

var F : (4 ° 4) := 4 * D;

var G : (4 ° 4) := F^2;
var H : (4 ° 4) := F^2 + F;

def is : (a : int) -> boolean {
	var a : int := 3;
	return a == a;
}

proc @print : () {
	var gh : int := 9;
	return;
}

proc @prints : (quert : boolean, m : ($k ° $l) , n : ($l ° $k)) {
	var other : ($k ° $l);
	var counter : int;
	from counter=1 to $k {
	}
}
