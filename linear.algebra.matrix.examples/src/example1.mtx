int var := 4 * 5;
int other := 4 + 5 * var;

boolean b := true;
boolean c := false;
bool e := b;

const int wert := 3;

int e := 4; § should fail
e := true;

if (e) {
	e := false;
} else if (e) {
} else {
	if (b) {}
}

boolean c := false;

int d := 5;

(4 ° 5) A := (dot 0) {
	5 5 5 . .
	4 3 2 . .
	1 . . . .
	1 2 3 4 5
};

(5 ° 4) B := int (dot 3) {
	2 . 4  5
	2 . 4  5
	2 . 45 5
	2 . 4  5
	2 . 4  5
};

(1 ° 1) J := int {
	1
};

(1 ° 1) HGF := J;
(1 ° 1) HGF2 := J * J;

(4 ° 5) L := B^T;
const boolean zzf := !(A ~ A);

int c := A[1, 2^2];

if (2 > 2) {}

if (B*A == B*A) {}
if (A == 2*A) {}

boolean b := A == A && 2 == 2;
boolean c := b == b;

if (b == true) {}

h := 4; § should error

(2 ° 3) C := {
	1 2 3
	4 5 6
};

(2 ° 2) Q := {
	1 2 3
	4 5 3
} * {
	1 2
	2 3
	1 1
};

(2 ° 3) Z := {
	1 2 3
	2 3 4
} * {
	1 2 3
	1 2 3
	1 2 3
};

(4 ° 4) D := A * B;
(5 ° 5) E := B * A;

E := -E;

(2 ° 3) g := 5 * C + 4 * C;
int h := (5 * 4)^0;

(4 ° 4) F := 4 * D;

(4 ° 4) G := F^2;
(4 ° 4) H := F^2 + F;

(1 ° 2) param1;
(2 ° 1) param2;

(1 ° 4) res := scalar_mult(param1, param2, 4);

@print();
@prints(true, param1, param2);

def scalar_mult : (($i ° $j) matr1, ($j ° $i) other, int scalar) -> ($i ° 4) {
	($i ° 4) F;
	int a;
	return (F := F);
	return F;
}

def is : (int a) -> boolean {
	int a := 3;
	return a == a;
}

proc @prints : (boolean quert, ($k ° $l) m, ($l ° $k) n) {
	($k ° $l) other;
}

proc @print : () {
	return;
	int b;
}
