int myvar := 4 * 5;
int other := 4 + 5 * myvar;

boolean b := true;
boolean cd := false;
int d := 0;
bool e := b;

var test := false;

const int wert := 3;

int ef := 4;
e := true;

if (e) {
	int e := 4;
	e := 2;
} else if (e) {
} else {
	if (b) {}
}

boolean c0 := false;
int d_ := 5;

var A := (dot 0) {
	5 5 5 . .
	4 3 2 . .
	1 . . . .
	1 2 3 4 5
};

var B := int (dot 3) {
	2 . 4  5
	2 . 4  5
	2 . 45 5
	2 . 4  5
	2 . 4  5
};

(1 ° 1) J := int {
	1
};

(1 ° 1) HGF := J;
(1 ° 1) HGF2 := J * J;

(4 ° 5) L := B^T;
const boolean zzf := !(A ~ A);

int c := A[1, 2^2];
int fgh;
A[1,1] := 0;

if (2 > 2) {}

if (B*A == B*A) {}
if (A == 2*A) {}

boolean b1 := A == A && 2 == 2;
boolean c1 := b == b;

if (b == true) {}

h := 4; § should error

(2 ° 3) C := {
	1 2 3
	4 5 6
};

var tern := 3 == 3 ? 4 : 1 == 2 ? 4 : 5;

var identity := init (int i..10, int j..10) ~> i == j ? 1 : 0;
var zero := init (int i..10, int j..10) ~> 0;
var D_init := init (int i..2, int j..3) ~> (i*j);

(2 ° 2) Q := {
	1 2 3
	4 5 3
} * {
	1 2
	2 3
	1 1
};

(2 ° 3) Z := {
	1 2 3
	2 3 4
} * {
	1 2 3
	1 2 3
	1 2 3
};

(4 ° 4) D := A * B;
(5 ° 5) E := B * A;

E := -E;

(2 ° 3) g := 5 * C + 4 * C;
int h := (5 * 4)^0;

(4 ° 4) F := 4 * D;

(4 ° 4) G := F^2;
(4 ° 4) H := F^2 + F;

(1 ° 2) param1;
(2 ° 1) param2;

(1 ° 4) res := scalar_mult(param1, param2, 4);

@prints(true, param1, param2);

def scalar_mult : (($i ° $j) matr1, ($j ° $i) other, int scalar) -> ($i ° 4) {
	($i ° 4) F;
	int a;
	return (F := F);
}

def is : (int a) -> boolean {
	int a := 3;
	return a == a;
}

proc @print : () {
	int gh := 9;
	return;
}

proc @prints : (boolean quert, ($k ° $l) m, ($l ° $k) n) {
	($k ° $l) other;
	int counter;
	from counter=1 to $k {
	}
}
