int var := 45;
int other := 4 + 5 * var;

boolean b := true;
boolean c := false;
bool e := b;

const int wert := 3;

int e := 4; § should fail
e := true;

if (e) {
	e := false;
	return e;
} else if (e) {
	return e;
} else {
	return b;
	if (b) {}
}

boolean c := false;

int d := 5;

return e;

(4 ° 5) A := (dot 0) {
	5 5 5 . .
	4 3 2 . .
	1 . . . .
	1 2 3 4 5
};

(5 ° 4) B := int (dot 3) {
	2 . 4  5
	2 . 4  5
	2 . 45 5
	2 . 4  5
	2 . 4  5
};

(1 ° 1) J := int {
	1
};

(4 ° 5) L := B^T;
const boolean zzf := !(A ~ A);

int c := A[1, 2^2];

if (2 > 2) {}

if (B*A == B*A) {}
if (A == 2*A) {}

boolean b := A == A && 2 == 2;
boolean c := b == b;

if (b == true) {}

h := 4; § should error

(2 ° 3) C := {
	1 2 3
	4 5 6
};

(2 ° 2) Q := {
	1 2 3
	4 5 3
} * {
	1 2
	2 3
	1 1
};

(2 ° 3) Z := {
	1 2 3
	2 3 4
} * {
	1 2 3
	1 2 3
	1 2 3
};

(4 ° 4) D := A * B;
(5 ° 5) E := B * A;

E := -E;

(2 ° 3) g := 5 * C + 4 * C;
int h := (5 * 4)^0;

(4 ° 4) F := 4 * D;

(4 ° 4) G := F^2;
(4 ° 4) H := F^2 + F;

scalar_mult(g, h);

def scalar_mult : ((2 ° 3) matr, int scalar) -> (2 ° 4) { § support ($i ° $j) type
	return 4; § check return type
}

proc print : (boolean quert) {
	§ todo
}
 