int myvar := 5;
(2 ° 3) matr := (dot 0) {
	1 . .
	0 1 0
};

(int, complex, (1 x 2)) t := (2,3i, {
	1 1
});
int i;
(1 x 2) n;

(i,, n) := t;
var (const rational ii,, nn) := t;
rational ratio := ii;

var matr2 := init (int i..2, int j..2) ~> i + j;

(2 ° 3) mult := matr;

ℤ ∋ other := myvar * 4;
int e := matr[1,1];
e := 4;
ℚ ∋ r := e / (1/2);

var x := 7;
int zl;
var zl_m := {
	zl := 5 5
};
@printNumber(zl_m[1,1]);
@printNumber(zl);

(3 x 4) CROSSED := {
	1 2 3 4
	1 2 3 4
	1 2 3 4
};

var test_im := 6i;

rational cde := 4 + 3/2;
var gre := 4/2 < 4;
var equ := 4 ≠ 4/1;

if (true) {
	boolean e;
	e := ¬true ∨ false;
}

internal def test : (($n ° $m) A ) -> int {
	return $n;
}

proc @myproc : () {}

@myproc();

var left := {
	1 0
	0 1
};
var right := {
	0 1
	1 0
};
var result := left * right;
var all_one := left + right;
var transposed := right^T;
var gen := test(left) + 1;

var zzz := {
	-4 4 -8
	4 -4 0
	-8 6 -9
};
var diagonal_zzz := stdlib::diagonalize(zzz);
var strict_zzz := stdlib::strictly_diagonalize(zzz);

var id := {
	1 0
	0 1
};
var abs := |-4|;
var det := |left|;

var equals := left = id;
var equivalent := zzz ~ diagonal_zzz;