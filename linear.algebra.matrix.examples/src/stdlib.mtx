def add : (($n ° $m) A, ($n ° $m) B) -> ($n ° $m) {
	return init (int i..$n, int j..$m) ~> A[i,j] + B[i,j];
}

def mult : (($n ° $m) A, ($m ° $k) B) -> ($n ° $k) {
	return init (int i..$n, int j..$k) ~> mult_vectors(A, B, i, j);
}

internal def mult_vectors : (($n ° $m) A, ($m ° $k) B, int line, int column) -> int {
	int i;
	int sum := 0;
	from i=1 to $m {
		sum := sum + A[line,i] * B[i,column];
	}
	return sum;
}

def minus : (($n ° $m) A) -> ($n ° $m) {
	return init (int i..$n, int j..$m) ~> -A[i,j];
}

def transpose : (($n ° $m) A) -> ($m ° $n) {
	return init (int i..$m, int j..$n) ~> A[j,i];
}

def exp : (($n ° $n) A, int exp) -> ($n ° $n) {
	if (exp == 0) § identity matrix
		return init (int i..$n, int j..$n) ~> i == j ? 1 : 0;
	if (exp < 0) {
		A := invert(A);
		exp := -exp;
	}
	int i;
	from i=2 to exp {
		A := A * A;
	}
	return A;
}

def scalar_mult : (($n ° $m) A, int scalar) -> ($n ° $m) {
	return init (int i..$n, int j..$m) ~> scalar * A[i,j];
}

def diagonal : (($n ° $m) A) -> boolean {
	boolean diagonal := true;
	int i; int j;
	from i=1 to $n {
		from j=1 to $m {
			diagonal := diagonal && (i == j || A[i,j] == 0);
		}
	}
	return diagonal;
}

def diagonalize : (($n ° $m) A) -> ($n ° $m) {
	while !(diagonal(A)) {
		int i := 1; int j := $m;
		while i = j || A[i,j] = 0 { § find highest priority index
			if (j > i) § currently walking from right to left...
				j := j - 1; § go further left
			else if (i > j) § currently walking from bottom to top
				if (j == i - 1) j := $m; § can't go higher, so do this line instead
				else i := i - 1; § else go up in the column
			else § we hit a diagonal entry => assuming we came from the right, do the column now
				i := $n;
		}

		if (j > i)
			A := columnDiagonalizeHelper(A, i, j);
		else
			A := transpose(columnDiagonalizeHelper(transpose(A), j, i));
	}
	return A;
}

internal def columnDiagonalizeHelper : (($n ° $m) A, int l, int c) -> ($n ° $m) {
	($m ° $m) Tilt;
	if (A[l,c] = A[l,c - 1])
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c - 1 && j = c) ? -1 : 0);
	else if (A[l,c] <= 0 && A[l,c - 1] > 0)
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c - 1 && j = c) ? 1 : 0);
	else if (A[l,c] > 0 && A[l,c - 1] <= 0)
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c && j = c - 1) ? 1 : 0);
	else if (A[l,c - 1] < A[l,c])
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c - 1 && j = c) ? -1 : 0);
	else §if (A[l,c] < A[l,c - 1])
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c && j = c - 1) ? -1 : 0);
	return mult(A, Tilt);
}

def strictly_diagonalize : (($n ° $m) A) -> ($n ° $m) {
	§ TODO
}

def equivalent : (($n ° $m) A, ($n ° $m) B) -> boolean {
	§ TODO
}

def similar : (($n ° $m) A, ($n ° $m) B) -> boolean {
	§ TODO
}

def det : (($n ° $n) A) -> int {
	§ TODO
}

def rational_canonical : (($n ° $m) A) -> ($n ° $m) {
	§ TODO
}

def invert : (($n ° $n) A) -> ($n ° $n) {
	§ TODO
}

def pseudo_invert : (($n ° $m) A) -> ($m ° $n) {
	§ TODO
}