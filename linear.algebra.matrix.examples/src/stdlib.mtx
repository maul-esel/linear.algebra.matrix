def conjugate : (complex z) -> complex {
	return core::re(z) - core::im(z) * 1i;
}

def add : (%t($n x $m) A, %t($n x $m) B) -> %t($n x $m) {
	return init (int i..$n, int j..$m) ~> A[i,j] + B[i,j];
}

def mult : (%t($n ° $m) A, %t($m ° $k) B) -> %t($n ° $k) {
	return init (int i..$n, int j..$k) ~> mult_vectors(A, B, i, j);
}

internal def mult_vectors : (%t($n ° $m) A, %t($m ° $k) B, int line, int column) -> %t {
	int i;
	%t sum := 0;
	from i=1 to $m {
		sum := sum + A[line,i] * B[i,column];
	}
	return sum;
}

def minus : (%t($n ° $m) A) -> %t($n ° $m) {
	return init (int i..$n, int j..$m) ~> -A[i,j];
}

def transpose : (%t($n ° $m) A) -> %t($m ° $n) {
	return init (int i..$m, int j..$n) ~> A[j,i];
}

def exp : (%t($n ° $n) A, int exp) -> %t($n ° $n) {
	if (exp == 0) § identity matrix
		return init (int i..$n, int j..$n) ~> i == j ? 1 : 0;
	if (exp < 0) {
§		A := invert(A); TODO
		exp := -exp;
	}
	int i;
	from i=2 to exp {
		A := A * A;
	}
	return A;
}

def scalar_mult : (%t($n ° $m) A, %t scalar) -> %t($n ° $m) {
	return init (int i..$n, int j..$m) ~> scalar * A[i,j];
}

def diagonal : (%t($n ° $m) A) -> boolean {
	boolean diagonal := true;
	int i; int j;
	from i=1 to $n {
		from j=1 to $m {
			diagonal := diagonal && (i == j || A[i,j] == 0);
		}
	}
	return diagonal;
}

def diagonalize : (%t($n ° $m) A) -> %t($n ° $m) {
	while !(diagonal(A)) {
		int i := 1; int j := $m;
		while i = j || A[i,j] = 0 { § find highest priority index
			if (j > i) § currently walking from right to left...
				j := j - 1; § go further left
			else if (i > j) § currently walking from bottom to top
				if (j == i - 1) j := $m; § can't go higher, so do this line instead
				else i := i - 1; § else go up in the column
			else § we hit a diagonal entry => assuming we came from the right, do the column now
				i := $n;
		}

		if (j > i)
			A := columnDiagonalizeHelper(A, i, j);
		else
			A := transpose(columnDiagonalizeHelper(transpose(A), j, i));
	}
	return A;
}

internal def columnDiagonalizeHelper : (%t($n ° $m) A, int l, int c) -> %t($n ° $m) {
	($m ° $m) Tilt;
	if (A[l,c] = A[l,c - 1])
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c - 1 && j = c) ? -1 : 0);
	else if (A[l,c] <= 0 && A[l,c - 1] > 0)
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c - 1 && j = c) ? 1 : 0);
	else if (A[l,c] > 0 && A[l,c - 1] <= 0)
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c && j = c - 1) ? 1 : 0);
	else if (A[l,c - 1] < A[l,c])
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c - 1 && j = c) ? -1 : 0);
	else §if (A[l,c] < A[l,c - 1])
		Tilt := init (int i..$m, int j..$m) ~> i = j ? 1 : ((i = c && j = c - 1) ? -1 : 0);
	return mult(A, Tilt);
}

def strictly_diagonalize : (($n ° $m) A) -> ($n ° $m) {
	A := diagonalize(A);
	int i;

	from i=2 to min($n,$m) {
		if (!is_multiple(A[i - 1,i - 1], A[i,i])) {
			var Tilt := init (int k..$n, int l..$n) ~> k = l ? 1 : ((k = i - 1 && l = i) ? 1 : 0); § add line i on line i-1
			return strictly_diagonalize(diagonalize(mult(Tilt, A)));
		}
	}

	from i=1 to min($n,$m) {
		if (A[i,i] < 0 && i < $m) { § negative entry except last column
			var Tilt := init (int k..$m, int l..$m) ~> k = l ? 1 : ((k = i && l = i + 1) ? -1 : 0); § subtract column i from column i + 1
			return strictly_diagonalize(diagonalize(mult(A, Tilt)));
		}
	}

	from i=1 to min($n,$m) {
		if (A[i,i] < 0 && i < $n) { § negative entry except last line
			var Tilt := init (int k..$n, int l..$n) ~> k = l ? 1 : ((k = i + 1 && l = i) ? -1 : 0); § subtract line i from line i + 1
			return strictly_diagonalize(diagonalize(mult(Tilt, A)));
		}
	}

	return A;
}

internal def min : (int a, int b) -> int { return a < b ? a : b; }

internal def is_multiple : (int factor, int product) -> boolean {
	int i;
	factor := abs(factor);
	product := abs(product);
	from i=0 to product {
		if (factor * i == product)
			return true;
	}
	return false;
}

internal def abs : (int i) -> int { return i >= 0 ? i : -i; }

def equivalent : (($n ° $m) A, ($n ° $m) B) -> boolean {
	return strictly_diagonalize(A) == strictly_diagonalize(B);
}

§§def similar : (($n ° $m) A, ($n ° $m) B) -> boolean {
	§ TODO
}§§

def det : (%t($n ° $n) A) -> %t {
	A := diagonalize(A);
	%t d := 1; int i;
	from i=1 to $n {
		d := d * A[i,i];
	}
	return d;
}

def tr : (%t($n ° $m) A) -> %t {
	A := diagonalize(A);
	%t t := 0; int i;
	from i=1 to min($n,$m) {
		t := t + A[i,i];
	}
	return t;
}

def rk : (%t($n ° $m) A) -> int {
	A := diagonalize(A);
	int r := 0; int i;
	from i=1 to min($n,$m) {
		r := r + (A[i,i] == 0 ? 0 : 1);
	}
	return r;
}

def column : (%t($n ° $m) A, int c) -> %t($n ° 1) {
	return init (int i..$n, int j..1) ~> A[i,c];
}

def line : (%t($n ° $m) A, int l) -> %t(1 ° $m) {
	return init (int i..1, int j..$m) ~> A[l, j];
}

§§def rational_canonical : (($n ° $m) A) -> ($n ° $m) {
	§ TODO
}§§

§§def invert : (($n ° $n) A) -> ($n ° $n) {
	§ TODO
}§§

§§def pseudo_invert : (($n ° $m) A) -> ($m ° $n) {
	§ TODO
}§§