system linear.algebra.matrix.interpreter.ExpressionInterpretation extends linear.algebra.matrix.semantics.Checks

import linear.algebra.matrix.matrix.*

import linear.algebra.matrix.interpreter.VariableRegister
import linear.algebra.matrix.interpreter.Interpreter
import linear.algebra.matrix.interpreter.CompareUtil

import linear.algebra.matrix.core.Matrix
import linear.algebra.matrix.core.IntegerMatrix
import linear.algebra.matrix.core.RationalMatrix
import linear.algebra.matrix.core.RealMatrix
import linear.algebra.matrix.core.ComplexMatrix
import linear.algebra.matrix.core.Rational
import linear.algebra.matrix.core.Complex
import static extension linear.algebra.matrix.core.NumberHelper.*

inject StdlibUtil util

auxiliary {
	createMatrix(MathematicalType entries, Integer lines, Integer columns) : Matrix<?>
	setMatrixEntry(Matrix<?> m, Integer i, Integer j, Number entry)
}

judgments {
    interpret |- Expression expr ~> output Object
}

auxiliary createMatrix(MathematicalType entries, Integer lines, Integer columns) {
	switch (entries) {
		IntegerType  : new IntegerMatrix(lines, columns)
		RationalType : new RationalMatrix(lines, columns)
		RealType     : new RealMatrix(lines, columns)
		ComplexType  : new ComplexMatrix(lines, columns)
	}
}

auxiliary setMatrixEntry(Matrix<?> m, Integer i, Integer j, Number entry) {
	switch (m) {
		IntegerMatrix  : m.setEntry(i, j, entry.intValue())
		RationalMatrix : m.setEntry(i, j, Rational.valueOf(entry))
		RealMatrix     : m.setEntry(i, j, entry.doubleValue())
		ComplexMatrix  : m.setEntry(i, j, Complex.valueOf(entry))
	}
}

axiom IVariable
	G |- Variable variable ~> env(G, 'variables', VariableRegister).get(variable.ref.name)

axiom IGenericVariable
	G |- GenericVariable variable ~> Integer.parseInt(env(G, 'generics', VariableRegister).get(variable.name) as String)

axiom IIntegerLiteral
	G |- IntLiteral lit ~> Integer.parseInt(lit.value)

axiom IBooleanLiteral
	G |- BooleanLiteral lit ~> Boolean.parseBoolean(lit.value)

axiom IRationalLiteral
	G |- RationalLiteral lit ~> new Rational(Integer.parseInt(lit.numerator), Integer.parseInt(lit.denominator))

axiom IRealLiteral
	G |- RealLiteral lit ~> Double.parseDouble(lit.value)

rule IImaginaryLiteral
	G |- ImaginaryLiteral lit ~> Complex z
from {
	G |- lit.coefficient ~> var Number c
	z = new Complex(0, c)
}

rule IVariableAssignment
	G |- VariableAssignment assign ~> Object value
from {
	G |- assign.variable : var Type type
	G |- assign.value ~> value
	env(G, 'variables', VariableRegister).set(assign.variable.ref.name,
		switch (type) {
			ComplexType  : Complex.valueOf(value)
			RealType     : (value as Number).doubleValue()
			RationalType : Rational.valueOf(value)
			default      : value
		})
}

rule ILogicalAndOr
	G |- LogicalAndOr comp ~> Boolean value
from {
	G |- comp.left ~> var Boolean left
	G |- comp.right ~> var Boolean right
	value = if (comp.op == LogicalOp.AND) (left && right) else (left || right)
}

rule IEquals
	G |- Equals eq ~> Boolean value
from {
	G |- eq.left ~> var Object left
	G |- eq.right ~> var Object right

	value = if (left == null)
		(right == null)
	else if (left instanceof Number && right instanceof Number)
		equality.of(left as Number, right as Number)
	else (left.equals(right))

	if (eq.op == EqualsOp.NOTEQUALS)
		value = !value
}

rule IComparison
	G |- Comparison comp ~> Boolean value
from {
	G |- comp.left ~> var Number left
	G |- comp.right ~> var Number right

	// complex should be filtered out by validation
	if (left instanceof Double || right instanceof Double)
		value = CompareUtil.compare(left.doubleValue(), right.doubleValue(), comp.op)
	else if (left instanceof Rational || right instanceof Rational)
		value = CompareUtil.compare(Rational.valueOf(left), Rational.valueOf(right), comp.op)
	else // two integers
		value = CompareUtil.compare(left as Integer, right as Integer, comp.op)
}

rule IEntryAssignment
	G |- MatrixEntryAssignment assign ~> Object result
from {
	G |- assign.matr ~> var Matrix<?> mat
	G |- assign.line ~> var Integer line
	G |- assign.column ~> var Integer column
	G |- assign.value ~> var Number value

	setMatrixEntry(mat, line, column, value)
	result = mat.getEntry(line, column)
}

rule IMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit ~> Matrix<?> m
from {
	G |- lit : var MatrixType matrType
	if (!matrType.isExact()) {
		val generics = env(G, 'generics', VariableRegister)
		matrType = makeExactFromGeneric(generics, matrType)
	}

	m = createMatrix(matrType.realEntryType, Integer.parseInt(matrType.height), Integer.parseInt(matrType.width))

	var i = 1
	for (line : lit.lines) {
		var j = 1
		var Number value
		for (entry : line.entries) {
			if (entry instanceof MathematicalLiteral) {
				G |- entry ~> value
			} else { // placeholder '.'
				G |- lit.dot.fill ~> value
			}
			setMatrixEntry(m, i, j, value)
			j = j + 1
		}
		i = i + 1
	}
}

rule IMatrixInit
	G |- MatrixInit init ~> Matrix<?> m
from {
	G |- init : var MatrixType matrType
	if (!matrType.isExact()) {
		val generics = env(G, 'generics', VariableRegister)
		matrType = makeExactFromGeneric(generics, matrType)
	}

	val variables = new VariableRegister(env(G, 'variables', VariableRegister))
	variables.add(init.line.name)
	variables.add(init.column.name)

	val lines = Integer.parseInt(matrType.height)
	val columns = Integer.parseInt(matrType.width)

	m = createMatrix(matrType.realEntryType, lines, columns)

	for (i : 1..lines)
		for (j : 1..columns) {
			variables.set(init.line.name, i)
			variables.set(init.column.name, j)
			G, 'variables' <- variables |- init.entry ~> var Number entry
			setMatrixEntry(m, i, j, entry)
		}
}

rule IParenthesis
	G |- ParenthesizedExpression par ~> Object o
from {
	G |- par.inner ~> o
}

rule IEntryAccess
	G |- EntryAccess acc ~> Object entry
from {
	G |- acc.matr ~> var Matrix<?> mat
	G |- acc.line ~> var Integer line
	G |- acc.column ~> var Integer column

	entry = mat.getEntry(line, column)
}

rule INegation
	G |- Negation neg ~> Boolean bool
from {
	G |- neg.expr ~> var Boolean inner
	bool = !inner
}

rule IExponentiation
	G |- Exponentiation expr ~> Object result
from {
	G |- expr.base ~> var Object base
	G |- expr.exp ~> var Integer exp
	if (base instanceof Matrix<?>) {
		val func = util.createMatrixExp(expr)
		G |- func ~> result
	} else if (base instanceof Number)
		 result = exp(base, exp)
	else {
		fail error "unsupported exponentiation" source expr
	}
}

rule IUnaryMinus
	G |- UnaryMinus minus ~> Object result
from {
	G |- minus.expr ~> var Object obj
	switch (obj) {
		Number  : result = negative.of(obj)
		Matrix<?>: {
			val func = util.createMatrixNegative(minus.expr)
			G |- func ~> result
		}
		default  : { fail error "unsupported unary minus" source minus }
	}
}

rule IAddition
	G |- Addition add ~> Object result
from {
	G |- add.left ~> var Object left
	G |- add.right ~> var Object right

	if (left instanceof Number && right instanceof Number) {
		result = switch (add.op) {
			case AdditionOp.PLUS : sum.of(left as Number, right as Number)
			case AdditionOp.MINUS : difference.of(left as Number, right as Number)
			default : null
		}
	} else if (left instanceof Matrix<?> && right instanceof Matrix<?>) {
		val func = switch (add.op) { // TODO: possible implicit cast
			case AdditionOp.PLUS : util.createMatrixAddition(add)
			case AdditionOp.MINUS : util.createMatrixSubtraction(add)
			default : null
		}
		G |- func ~> result
	} else { fail error "unsupported addition" source add }
}

rule IDivision
	G |- Division div ~> Number result
from {
	G |- div.left ~> var Number left
	G |- div.right ~> var Number right

	result = quotient.of(left, right)
	// TODO: matrix division by scalar (i.e. multiply by 1/scalar)
}

rule IMultiplication
	G |- Multiplication mult ~> Object result
from {
	G |- mult.left ~> var Object left
	G |- mult.right ~> var Object right

	if (left instanceof Matrix<?> && right instanceof Matrix<?>) {
		val func = util.createMatrixMultiplication(mult)
		G |- func ~> result // TODO: possible implicit cast
	} else if (left instanceof Matrix<?> || right instanceof Matrix<?>) {
		val func = util.createScalarMultiplication(mult,
			if (left instanceof Matrix<?>) mult.right else mult.left)
		G |- func ~> result // TODO: possible implicit cast
	} else if (left instanceof Number && right instanceof Number)
		result = product.of(left as Number, right as Number)
	else { fail error "unsupported multiplication" source mult }
}

rule IFunctionCall
	G |- FunctionCall call ~> Object result
from {
	result = env(G, "interpreter", Interpreter).evaluate(call,
		env(G, 'variables', VariableRegister),
		env(G, 'generics', VariableRegister)
	)
}

rule ITernary
	G |- Ternary ter ~> Object result
from {
	G |- ter.cond ~> var Boolean cond
	if (cond) {
		G |- ter.ifTrue ~> result
	} else {
		G |- ter.ifFalse ~> result
	}
}

rule IDeterminantOrAbsoluteValue
	G |- DeterminantOrAbsoluteValue expr ~> Object result
from {
	G |- expr.inner ~> var Object inner
	if (inner instanceof Matrix<?>) {
		val func = util.createDeterminant(expr)
		G |- func ~> result
	} else if (inner instanceof Number)
		result = abs.of(inner)
}

rule ITransposition
	G |- Transposition trans ~> Matrix<?> result
from {
	val func = util.createTransposition(trans)
	G |- func ~> result
}

rule IEquivalency
	G |- Equivalency eq ~> Boolean result
from {
	val func = util.createEquivalency(eq) // TODO: possible implicit cast
	G |- func ~> result
}