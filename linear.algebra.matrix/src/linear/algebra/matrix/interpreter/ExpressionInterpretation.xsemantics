system linear.algebra.matrix.interpreter.ExpressionInterpretation extends linear.algebra.matrix.semantics.Checks

import linear.algebra.matrix.matrix.*
import static extension linear.algebra.matrix.matrix.MatrixTypeUtil.*

import linear.algebra.matrix.interpreter.VariableRegister
import linear.algebra.matrix.interpreter.Interpreter
import linear.algebra.matrix.interpreter.CompareUtil

import linear.algebra.matrix.core.Matrix
import linear.algebra.matrix.core.IntegerMatrix
import linear.algebra.matrix.core.RationalMatrix
import linear.algebra.matrix.core.Rational

inject StdlibUtil util

auxiliary {
	makeExactFromGeneric(VariableRegister generics, MatrixType matrType) : MatrixType
}

judgments {
    interpret |- Expression expr ~> output Object
}

auxiliary makeExactFromGeneric(VariableRegister generics, MatrixType matrType) {
	MatrixTypeUtil.create(
		if (isGeneric(matrType.height)) generics.get(matrType.height) as String else matrType.height,
		if (isGeneric(matrType.width)) generics.get(matrType.width) as String else matrType.width,
		matrType.actualEntryType
	)
}

axiom IVariable
	G |- Variable variable ~> env(G, 'variables', VariableRegister).get(variable.ref.name)

axiom IGenericVariable
	G |- GenericVariable variable ~> Integer.parseInt(env(G, 'generics', VariableRegister).get(variable.name) as String)

axiom IIntegerLiteral
	G |- IntLiteral lit ~> Integer.parseInt(lit.value)

axiom IBooleanLiteral
	G |- BooleanLiteral lit ~> Boolean.parseBoolean(lit.value)

axiom IRationalLiteral
	G |- RationalLiteral lit ~> new Rational(Integer.parseInt(lit.numerator), Integer.parseInt(lit.denominator))

rule IVariableAssignment
	G |- VariableAssignment assign ~> Object value
from {
	G |- assign.variable : var Type type
	G |- assign.value ~> value
	env(G, 'variables', VariableRegister).set(assign.variable.ref.name,
		if (type instanceof RationalType) Rational.valueOf(value) else value)
}

rule ILogicalAndOr
	G |- LogicalAndOr comp ~> Boolean value
from {
	G |- comp.left ~> var Boolean left
	G |- comp.right ~> var Boolean right
	value = if (comp.op == LogicalOp.AND) (left && right) else (left || right)
}

rule IEquals
	G |- Equals eq ~> Boolean value
from {
	G |- eq.left ~> var Object left
	G |- eq.right ~> var Object right

	value = if (left == null)
		(right == null)
	else if (left instanceof Rational && right instanceof Integer)
		left.equals(new Rational(right as Integer))
	else if (left instanceof Integer && right instanceof Rational)
		right.equals(new Rational(left as Integer))
	else (left.equals(right))

	if (eq.op == EqualsOp.NOTEQUALS)
		value = !value
}

rule IComparison
	G |- Comparison comp ~> Boolean value
from {
	G |- comp.left ~> var Object left
	G |- comp.right ~> var Object right

	if (left instanceof Rational || right instanceof Rational) {
		value = CompareUtil.compare(Rational.valueOf(left), Rational.valueOf(right), comp.op)
	} else { // two integers
		value = CompareUtil.compare(left as Integer, right as Integer, comp.op)
	}
}

rule IEntryAssignment
	G |- MatrixEntryAssignment assign ~> Object result
from {
	G |- assign.matr ~> var Matrix<?> mat
	G |- assign.line ~> var Integer line
	G |- assign.column ~> var Integer column
	G |- assign.value ~> var Object value

	if (mat instanceof IntegerMatrix)
		mat.setEntry(line, column, value as Integer)
	else if (mat instanceof RationalMatrix)
		mat.setEntry(line, column, Rational.valueOf(value))

	result = mat.getEntry(line, column)
}

rule IMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit ~> Matrix<?> m
from {
	G |- lit : var MatrixType matrType
	if (!matrType.isExact()) {
		val generics = env(G, 'generics', VariableRegister)
		matrType = makeExactFromGeneric(generics, matrType)
	}

	m = if (matrType.actualEntryType instanceof IntegerType)
		new IntegerMatrix(Integer.parseInt(matrType.height), Integer.parseInt(matrType.width))
	else if (matrType.actualEntryType instanceof RationalType)
		new RationalMatrix(Integer.parseInt(matrType.height), Integer.parseInt(matrType.width))

	var i = 1
	for (line : lit.lines) {
		var j = 1
		var Object value
		for (entry : line.entries) {
			if (entry instanceof MathematicalLiteral) {
				G |- entry ~> value
			} else { // placeholder '.'
				G |- lit.dot.fill ~> value
			}
			if (m instanceof IntegerMatrix)
				m.setEntry(i, j, value as Integer)
			else if (m instanceof RationalMatrix)
				m.setEntry(i, j, Rational.valueOf(value))
			j = j + 1
		}
		i = i + 1
	}
}

rule IMatrixInit
	G |- MatrixInit init ~> Matrix<?> m
from {
	G |- init : var MatrixType matrType
	if (!matrType.isExact()) {
		val generics = env(G, 'generics', VariableRegister)
		matrType = makeExactFromGeneric(generics, matrType)
	}

	val variables = new VariableRegister(env(G, 'variables', VariableRegister))
	variables.add(init.line.name)
	variables.add(init.column.name)

	val lines = Integer.parseInt(matrType.height)
	val columns = Integer.parseInt(matrType.width)

	m = if (matrType.actualEntryType instanceof IntegerType)
		new IntegerMatrix(lines, columns)
	else if (matrType.actualEntryType instanceof RationalType)
		new RationalMatrix(lines, columns)

	for (i : 1..lines)
		for (j : 1..columns) {
			variables.set(init.line.name, i)
			variables.set(init.column.name, j)
			G, 'variables' <- variables |- init.entry ~> var Object entry
			if (m instanceof IntegerMatrix)
				m.setEntry(i, j, entry as Integer)
			else if (m instanceof RationalMatrix)
				m.setEntry(i, j, Rational.valueOf(entry))
		}
}

rule IParenthesis
	G |- ParenthesizedExpression par ~> Object o
from {
	G |- par.inner ~> o
}

rule IEntryAccess
	G |- EntryAccess acc ~> Object entry
from {
	G |- acc.matr ~> var Matrix<?> mat
	G |- acc.line ~> var Integer line
	G |- acc.column ~> var Integer column

	entry = mat.getEntry(line, column)
}

rule INegation
	G |- Negation neg ~> Boolean bool
from {
	G |- neg.expr ~> var Boolean inner
	bool = !inner
}

rule IExponentiation
	G |- Exponentiation expr ~> Object result
from {
	G |- expr.base ~> var Object base
	G |- expr.exp ~> var Integer exp
	if (base instanceof Integer)
		result = Math.pow(base, exp)
	else if (base instanceof Rational) {
		result = Rational.exp(base, exp)
	} else if (base instanceof Matrix<?>) {
		val func = util.createMatrixExp(expr)
		G |- func ~> result
	} else {
		fail error "unsupported exponentiation" source expr
	}
}

rule IUnaryMinus
	G |- UnaryMinus minus ~> Object result
from {
	G |- minus.expr ~> var Object obj
	switch (obj) {
		Integer  : result = -obj
		Rational : result = obj.negative
		Matrix<?>: {
			val func = util.createMatrixNegative(minus.expr)
			G |- func ~> result
		}
		default  : { fail error "unsupported unary minus" source minus }
	}
}

rule IAddition
	G |- Addition add ~> Object result
from {
	G |- add.left ~> var Object left
	G |- add.right ~> var Object right

	if (left instanceof Integer && right instanceof Integer) {
		result = switch (add.op) {
			case AdditionOp.PLUS : (left as Integer) + (right as Integer)
			case AdditionOp.MINUS : (left as Integer) - (right as Integer)
			default : null
		}
	} else if (left instanceof Rational || right instanceof Rational) {
		result = switch (add.op) {
			case AdditionOp.PLUS : Rational.add(Rational.valueOf(left), Rational.valueOf(right))
			case AdditionOp.MINUS : Rational.subtract(Rational.valueOf(left), Rational.valueOf(right))
			default : null
		}
	} else if (left instanceof Matrix<?> && right instanceof Matrix<?>) {
		val func = switch (add.op) { // TODO: possible implicit cast
			case AdditionOp.PLUS : util.createMatrixAddition(add)
			case AdditionOp.MINUS : util.createMatrixSubtraction(add)
			default : null
		}
		G |- func ~> result
	} else { fail error "unsupported addition" source add }
}

rule IDivision
	G |- Division div ~> Rational result
from {
	G |- div.left ~> var Object left
	G |- div.right ~> var Object right

	val divisor = Rational.valueOf(right)
	(!divisor.equals(Rational.ZERO)) or fail error "Division by zero" source div.right
	result = Rational.divide(Rational.valueOf(left), divisor)
	// TODO: matrix division by scalar (i.e. multiply by 1/scalar)
}

rule IMultiplication
	G |- Multiplication mult ~> Object result
from {
	G |- mult.left ~> var Object left
	G |- mult.right ~> var Object right

	if (left instanceof Matrix<?> && right instanceof Matrix<?>) {
		val func = util.createMatrixMultiplication(mult)
		G |- func ~> result // TODO: possible implicit cast
	} else if (left instanceof Matrix<?> || right instanceof Matrix<?>) {
		val func = util.createScalarMultiplication(mult,
			if (left instanceof Matrix) mult.right else mult.left)
		G |- func ~> result // TODO: possible implicit cast
	} else if (left instanceof Integer && right instanceof Integer) {
		result = (left as Integer) * (right as Integer)
	} else if (left instanceof Rational || right instanceof Rational) {
		result = Rational.multiply(Rational.valueOf(left), Rational.valueOf(right))
	} else { fail error "unsupported multiplication" source mult }
}

rule IFunctionCall
	G |- FunctionCall call ~> Object result
from {
	result = env(G, "interpreter", Interpreter).evaluate(call,
		env(G, 'variables', VariableRegister),
		env(G, 'generics', VariableRegister)
	)
}

rule ITernary
	G |- Ternary ter ~> Object result
from {
	G |- ter.cond ~> var Boolean cond
	if (cond) {
		G |- ter.ifTrue ~> result
	} else {
		G |- ter.ifFalse ~> result
	}
}

rule IDeterminantOrAbsoluteValue
	G |- DeterminantOrAbsoluteValue expr ~> Object result
from {
	G |- expr.inner ~> var Object inner
	if (inner instanceof Matrix<?>) {
		val func = util.createDeterminant(expr)
		G |- func ~> result
	} else if (inner instanceof Integer)
		result = Math.abs(inner)
	else if (inner instanceof Rational)
		result = inner.abs()
}

rule ITransposition
	G |- Transposition trans ~> Matrix<?> result
from {
	val func = util.createTransposition(trans)
	G |- func ~> result
}

rule IEquivalency
	G |- Equivalency eq ~> Boolean result
from {
	val func = util.createEquivalency(eq) // TODO: possible implicit cast
	G |- func ~> result
}