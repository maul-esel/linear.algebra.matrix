system linear.algebra.matrix.semantics.CommonType
	extends linear.algebra.matrix.semantics.Subtyping

import linear.algebra.matrix.matrix.Type
import linear.algebra.matrix.matrix.TupleType
import linear.algebra.matrix.matrix.SetType
import linear.algebra.matrix.matrix.ListType
import linear.algebra.matrix.matrix.MatrixFactory

judgments {
	generalType |- Type first ~~ Type second |> output Type
		error "No common super type for types " + stringRep(first) + " and " + stringRep(second)
	commonType |- Iterable<Type> types |> output Type
}

rule CTDefault
	G |- Iterable<Type> types |> Type common
from  {
	if (types.length == 0)
		common = null
	else {
		val iterator = types.iterator()
		common = iterator.next()
		while (iterator.hasNext()) {
			G |- iterator.next() ~~ common |> common
		}
	}
}

rule ADefault
	G |- Type first ~~ Type second |> Type type
from {
	{
		G |- first <: second
		type = second
	} or {
		G |- second <: first
		type = first
	}
}

rule ATupleTypes
	G |- TupleType first ~~ TupleType second |> TupleType combined
from {
	{ first.types.size == second.types.size }
	combined = MatrixFactory.eINSTANCE.createTupleType()
	for (i : 0..<first.types.size) {
		G |- first.types.get(i) ~~ second.types.get(i) |> var Type common
		combined.types.add(common)
	}
}

rule ASetTypes
	G |- SetType first ~~ SetType second |> SetType common
from {
	var Type commonEntryType = null
	try { G |- first.entryType ~~ second.entryType |> commonEntryType }
	catch (Exception e) {}

	common = MatrixFactory.eINSTANCE.createSetType()
	common.entryType = commonEntryType ?: first.entryType ?: second.entryType
	common.isFinite = first.isFinite && second.isFinite
}

rule AListTypes
	G |- ListType first ~~ ListType second |> ListType common
from {
	var Type commonEntryType = null
	try { G |- first.entryType ~~ second.entryType |> commonEntryType }
	catch (Exception e) {}

	common = MatrixFactory.eINSTANCE.createListType()
	common.entryType = commonEntryType ?: first.entryType ?: second.entryType
}

rule ASetListTypes
	G |- SetType first ~~ ListType second |> SetType common
from {
	var Type commonEntryType = null
	try { G |- first.entryType ~~ second.entryType |> commonEntryType }
	catch (Exception e) {}

	common = MatrixFactory.eINSTANCE.createSetType()
	common.entryType = commonEntryType ?: first.entryType ?: second.entryType
	common.isFinite = first.isFinite // lists are always finite
}

rule AListSetTypes
	G |- ListType first ~~ SetType second |> SetType common
from {
	G |- second ~~ first |> common
}