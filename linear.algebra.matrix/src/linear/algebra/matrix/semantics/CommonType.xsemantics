system linear.algebra.matrix.semantics.CommonType
	extends linear.algebra.matrix.semantics.Subtyping

import linear.algebra.matrix.matrix.Type
import linear.algebra.matrix.matrix.TupleType
import linear.algebra.matrix.matrix.SetType
import linear.algebra.matrix.matrix.ListType
import linear.algebra.matrix.matrix.MatrixFactory

judgments {
	generalType |- Type first ~~ Type second |> output Type
		error "No common super type for types " + stringRep(first) + " and " + stringRep(second)
}

rule ADefault
	G |- Type first ~~ Type second |> Type type
from {
	{
		G |- first <: second
		type = second
	} or {
		G |- second <: first
		type = first
	}
}

rule ATupleTypes
	G |- TupleType first ~~ TupleType second |> TupleType combined
from {
	{ first.types.size == second.types.size }
	combined = MatrixFactory.eINSTANCE.createTupleType()
	for (i : 0..<first.types.size) {
		G |- first.types.get(i) ~~ second.types.get(i) |> var Type common
		combined.types.add(common)
	}
}

rule ASetTypes
	G |- SetType first ~~ SetType second |> SetType common
from {
	G |- first.entryType ~~ second.entryType |> var Type commonEntryType
	common = MatrixFactory.eINSTANCE.createSetType()
	common.entryType = commonEntryType
	common.isFinite = first.isFinite && second.isFinite
}

rule AListTypes
	G |- ListType first ~~ ListType second |> ListType common
from {
	G |- first.entryType ~~ second.entryType |> var Type commonEntryType
	common = MatrixFactory.eINSTANCE.createListType()
	common.entryType = commonEntryType
}

rule ASetListTypes
	G |- SetType first ~~ ListType second |> SetType common
from {
	G |- first.entryType ~~ second.entryType |> var Type commonEntryType
	common = MatrixFactory.eINSTANCE.createSetType()
	common.entryType = commonEntryType
	common.isFinite = first.isFinite // lists are always finite
}

rule AListSetTypes
	G |- ListType first ~~ SetType second |> SetType common
from {
	G |- second ~~ first |> common
}