system linear.algebra.matrix.semantics.Checks extends linear.algebra.matrix.semantics.Typing

import org.eclipse.emf.ecore.EObject
import linear.algebra.matrix.matrix.*
import linear.algebra.matrix.interpreter.VariableRegister
import linear.algebra.matrix.imports.ImportManagerFactory

inject ImportManagerFactory importFactory

auxiliary {
	hasPlaceholders(MultiLineMatrixLiteral lit) : Boolean
	isTypeDefinedByParams(Type type, ParameterList list) : Boolean
	isGenericInParamList(MatrixType type, ParameterList list) : Boolean
	isGenericVariableDefined(String generic, ParameterList list) : Boolean
	alwaysReturns(EObject obj) : Boolean
}

auxiliary hasPlaceholders(MultiLineMatrixLiteral lit) {
	var placeholders = false;
	for (line : lit.lines) {
		for (entry : line.entries) {
			placeholders = placeholders || (entry instanceof PlaceholderEntry)
		}
	}
	placeholders
}

auxiliary isTypeDefinedByParams(Type type, ParameterList list) {
	val paramTypes = list.params.map [ param | param.type ]

	val dimensionsDefined = if (type instanceof MatrixType) {
		val definedDimensions = paramTypes.filter [ paramType | paramType instanceof MatrixType ]
			.map [ matrType | newArrayList((matrType as MatrixType).height, (matrType as MatrixType).width) ]
			.flatten.filter [ dim | isGeneric(dim) ].toSet()
		(!isGeneric(type.height) || definedDimensions.contains(type.height))
			&& (!isGeneric(type.width) || definedDimensions.contains(type.width))
	} else true

	val typeDefined = if (type instanceof GenericType
		|| (type instanceof MatrixType && (type as MatrixType).realEntryType instanceof GenericType)) {
		val definedTypes = (paramTypes.filter [ paramType | paramType instanceof GenericType ]
				.map [ paramType | (paramType as GenericType).name ]
			+ paramTypes.filter [ paramType | paramType instanceof MatrixType ]
				.map [ paramType | (paramType as MatrixType).realEntryType ]
				.filter [ entryType | entryType instanceof GenericType ]
				.map [ entryType | (entryType as GenericType).name ]).toSet
		if (type instanceof GenericType)
			definedTypes.contains(type.name)
		else
			definedTypes.contains(((type as MatrixType).realEntryType as GenericType).name)
	} else true

	dimensionsDefined && typeDefined
}

auxiliary isGenericInParamList(MatrixType type, ParameterList list) {
	val height = type.height
	val width = type.width

	var heightFound = !isGeneric(height) // not generic dimensions are assumed to be "found" i.e. valid
	var widthFound = !isGeneric(width)

	for (param : list.params) {
		empty ||- param : var Type paramType
		if (paramType instanceof MatrixType) {
			heightFound = heightFound || paramType.height == height || paramType.width == height
			widthFound = widthFound || paramType.height == width || paramType.width == width
		}
	}
	widthFound && heightFound
}

auxiliary isGenericVariableDefined(String generic, ParameterList list) {
	var found = false
	for (param : list.params) {
		empty ||- param : var Type paramType
		if (paramType instanceof MatrixType)
			found = found || paramType.height == generic || paramType.width == generic
	}
	found
}

auxiliary alwaysReturns(EObject obj) {
	false
}

auxiliary alwaysReturns(ReturnStatement ret) {
	true
}

auxiliary alwaysReturns(Block block) {
	var returns = false
	for (line : block.lines)
		returns = returns || alwaysReturns(line)
	returns
}

auxiliary alwaysReturns(IfElse ifElse) {
	if (ifElse.getElse == null)
		false
	else
		alwaysReturns(ifElse.ifTrue) && alwaysReturns(ifElse.getElse)
}

auxiliary alwaysReturns(FromToLoop loop) {
	alwaysReturns(loop.body)
}

auxiliary alwaysReturns(WhileLoop loop) {
	alwaysReturns(loop.body)
}

checkrule CVarDeclarationIsTyped
	for VarDeclaration variable
from {
	empty ||- variable : var Type vartype
}

checkrule CAssignmentIsTyped
	for Assignment assign
from {
	empty |- assign : var Type type
}

checkrule CFunctionCallIsTyped
	for FunctionCall call
from {
	empty |- call : var Type type
}

checkrule CReturnStatementIsTyped
	for ReturnStatement ret
from {
	if (ret.value != null) {
		empty |- ret.value : var Type type
	}
}

checkrule CIfConditionIsTyped
	for IfElse ifelse
from {
	empty |- ifelse.cond : var BooleanType type
}

checkrule CMatrixLiteralHasDot
	for MultiLineMatrixLiteral lit
from {
	{ lit.dot != null || !hasPlaceholders(lit) }
	or fail error "Literal references undefined placeholder '.'"
		source lit
}

checkrule CMatrixInitHasProperExpression
	for MatrixInit init
from {
	empty |- init : var MatrixType type
	{
		empty |- init.entry : var Type entryType
		empty |- entryType <: type.realEntryType
	} or fail error "Matrix initialization expression is of incompatible type"
		source init.entry
}

checkrule CMatrixLiteralHashValidEntries
	for MultiLineMatrixLiteral lit
from {
	empty |- lit : var MatrixType type

	if (lit.dot != null) {
		empty |- lit.dot.fill : var Type dotType
		empty |- dotType <: type.realEntryType
		or fail error "Matrix entry placeholder is of incompatible type"
			source lit.dot
	}

	for (line : lit.lines)
		for (entry : line.entries)
			if (entry instanceof MathematicalLiteral) { // i.e. not a placeholder
				empty |- entry : var Type entryType
				empty |- entryType <: type.realEntryType
				or fail error "Matrix entry is of incompatible type"
					source entry
			}
}

checkrule CNoConstAssign
	for VariableAssignment assign
from {
	(!assign.variable.ref.const)
	or fail
		error "Cannot assign value to constant variable"
		source assign
}

checkrule CConstVarHasValue
	for VarDeclaration variable
from {
	{ (!variable.const || variable.value != null) }
	or fail error "Constant variable must be assigned a value on declaration"
		source variable
}

checkrule CInferredVarHasValue
	for InferredVarDeclaration variable
from {
	{ variable.value != null }
	or fail error "Variable with inferred type must be assigned value"
		source variable
}

checkrule CVarDeclHasCompatibleValueType
	for VarDeclaration variable
from {
	if (variable.value != null) {
		empty ||- variable : var Type vartype
		empty |- variable.value : var Type valtype
		empty |- valtype <: vartype
		or fail error "Value of type " + stringRep(valtype) + " cannot be assigned to variable of type " + stringRep(vartype)
			source variable.value
	}
}

checkrule CGenericVarDeclarationDefined
	for VarDeclaration variable
from {
	empty ||- variable : var Type vartype

	var container = variable.eContainer;
	while (container != null && !(container instanceof FuncDeclaration) && !(container instanceof ProcDeclaration))
		container = container.eContainer;

	if (vartype instanceof GenericType || ((vartype instanceof MatrixType) && (vartype as MatrixType).isGeneric())) {
		(container != null)
		or fail error "Generic variable definitions may only occur in functions and procs"
			source variable

		{ (container instanceof FuncDeclaration && (isTypeDefinedByParams(vartype, (container as FuncDeclaration).params))) }
		or { (container instanceof ProcDeclaration && (isTypeDefinedByParams(vartype, (container as ProcDeclaration).params))) }
		or fail error "Variable definition references unknown generic type"
			source variable
	}
}

checkrule CGenericVariable
	for GenericVariable gen
from {
	var container = gen.eContainer;
	while (container != null && !(container instanceof FuncDeclaration) && !(container instanceof ProcDeclaration))
		container = container.eContainer;

	(container != null) && (
		(container instanceof FuncDeclaration && (isGenericVariableDefined(gen.name, (container as FuncDeclaration).params)))
		|| (container instanceof ProcDeclaration && (isGenericVariableDefined(gen.name, (container as ProcDeclaration).params)))
	)
	or fail error "References undefined generic variable"
		source gen
}

checkrule CVarDeclarationIsUnique
	for VarDeclaration decl
from {
	val container = decl.eContainer
	for (other : container.eContents)
		{ !(other instanceof VarDeclaration) || ((other as VarDeclaration).name != decl.name) || (other == decl) }
		or fail error "variable names must be unique"
			source decl
}

checkrule CFuncDeclarationIsUnique // currently no overloads allowed
	for FuncDeclaration decl
from {
	val container = decl.eContainer // should be a Code instance
	for (other : container.eContents)
		{ !(other instanceof FuncDeclaration) || ((other as FuncDeclaration).name != decl.name) || (other == decl) }
		or fail error "function names must be unique"
			source decl
}

checkrule CProcDeclarationIsUnique // currently no overloads allowed
	for ProcDeclaration decl
from {
	val container = decl.eContainer // should be a Code instance
	for (other : container.eContents)
		{ !(other instanceof ProcDeclaration) || ((other as ProcDeclaration).name != decl.name) || (other == decl) }
		or fail error "proc names must be unique"
			source decl
}

checkrule CFunctionCallHasValidParameters
	for FunctionCall call
from {
	{ call.func.ref.params.params.size == call.params.size }
	or fail error "Function call has invalid number of parameters (expected " + call.func.ref.params.params.size + ", found " + call.params.size + ")"
		source call
}

checkrule CFunctionDeclarationHasNoDefaultValues
	for FuncDeclaration decl
from {
	for (param : decl.params.params) {
		param.value == null
		or fail error "Parameter default values are not allowed"
			source param.value
	}
}

checkrule CFuncDeclarationGenericReturnTypeDefined
	for FuncDeclaration func
from {
	(isTypeDefinedByParams(func.returnType, func.params))
	or fail error "Generic return type " + stringRep(func.returnType) + " is not defined"
		source func.returnType
}

checkrule CFuncDeclarationAlwaysReturns
	for FuncDeclaration func
from {
	alwaysReturns(func.body)
	or fail error "Not all code paths return a value"
		source func
}

checkrule CReturnStatement
	for ReturnStatement ret
from {
	var container = ret.eContainer
	while (container != null && !(container instanceof FuncDeclaration) && !(container instanceof ProcDeclaration))
		container = container.eContainer

	{ (container != null) }
	or fail error "Return must be inside a function or proc declaration"
		source ret

	if (container instanceof FuncDeclaration) {
		{ ret.value != null }
		or fail error "Return must specify return value"
			source ret

		{
			empty |- ret.value : var Type type
			empty |- type <: container.returnType
		} or fail error "expression type does not match function return type"
			source ret.value
	}
	else if (container instanceof ProcDeclaration) {
		ret.value == null
		or fail error "Proc cannot return a value"
			source ret.value
	}
}

checkrule CProcCallHasValidParameters
	for ProcCall call
from {
	{ call.proc.ref.params.params.size == call.params.size }
	or fail error "Proc call has invalid number of parameters (expected " + call.proc.ref.params.params.size + ", found " + call.params.size + ")"
		source call

	val genReg = new VariableRegister();
	{ checkParamTypes(genReg, call.proc.ref.params.params, call.params) }
}

checkrule CProcDeclarationHasNoDefaultValues
	for ProcDeclaration proc
from {
	for (param : proc.params.params) {
		param.value == null
		or fail error "Parameter default values are not allowed"
			source param.value
	}
}

checkrule CFromToLoop
	for FromToLoop loop
from {
	{ !loop.getVar.ref.const }
	or fail error "Cannot use constant as loop counter"
		source loop.getVar

	var IntegerType intType
	empty ||- loop.getVar.ref : intType
		or fail error "counter var must be integer" source loop.getVar
	empty |- loop.init : intType
		or fail error "initial value must be integer" source loop.init
	empty |- loop.end : intType
		or fail error "end value must be integer" source loop.end
}

checkrule CWhileLoop
	for WhileLoop loop
from {
	empty |- loop.cond : var BooleanType bool
	or fail error "condition must be boolean"
		source loop.cond
}

checkrule CBlockHasNoUnreachableCode
	for Block block
from {
	var reachable = true;
	for (line : block.lines) {
		{ reachable }
		or fail error "Unreachable code detected"
			source line
		if (alwaysReturns(line))
			reachable = false
	}
}

checkrule CImportIsUnique
	for Import imp
from {
	(imp.eContainer as Code).imports.forEach [ other |
		{ other.getSource != imp.getSource || other == imp }
		or fail error "Duplicate import of '" + imp.getSource + "'"
			source imp
	]
}

checkrule CNoDivisionByZero
	for Division div
from {
	if (div.right instanceof IntLiteral) {
		Integer.parseInt((div.right as IntLiteral).value) != 0
		or fail error "Cannot divide by zero"
			source div.right
	} else if (div.right instanceof RationalLiteral) {
		Integer.parseInt((div.right as RationalLiteral).numerator) != 0
		or fail error "Cannot divide by zero"
			source div.right
	}
}

checkrule CRationalNoDivisionByZero
	for RationalLiteral frac
from {
	Integer.parseInt(frac.denominator) != 0
	or fail error "Division by zero is not allowed"
		source frac
		feature MatrixPackage.eINSTANCE.rationalLiteral_Denominator
}

checkrule CImportIsValid
	for Import imp
from {
	val manager = importFactory.create(imp.eResource)
	if (!manager.isValidImport(imp.getSource)) {
		fail error "Import is not valid"
			source imp
			feature MatrixPackage.eINSTANCE.import_Source
	}
}