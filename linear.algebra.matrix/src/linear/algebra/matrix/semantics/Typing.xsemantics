system linear.algebra.matrix.semantics.Typing

validatorExtends linear.algebra.matrix.validation.AbstractMatrixValidator

import linear.algebra.matrix.matrix.*
import static extension linear.algebra.matrix.matrix.MatrixTypeUtil.*
import linear.algebra.matrix.interpreter.VariableRegister
import java.util.List

auxiliary {
	genericVarMatches(VariableRegister genReg, String variable, String value) : boolean
	checkParamTypes(VariableRegister genReg, List<TypedVarDeclaration> declaredParams, List<Expression> suppliedParams)
	genericTypeMatches(VariableRegister genReg, GenericType generic, MathematicalType value) : boolean
	isGeneric(String size) : boolean
	consistentLineWidth(MultiLineMatrixLiteral lit) : boolean
	isSquare(MatrixType type) : boolean
	matrixMultiplicationDefined(MatrixType left, MatrixType right) : boolean
	multipliedMatrixType(MatrixType left, MatrixType right) : MatrixType
	transpose(MatrixType type) : MatrixType
	superType(Type a, Type b) : Type
	scalarMultType(MathematicalType scalar, MatrixType matr) : MatrixType
}

judgments {
	type |- Expression expr : output Type
		error "Cannot type " + stringRep(expr)
		source expr
	subtype |- Type sub <: Type sup
    vartype ||- VarDeclaration decl : output Type
}

auxiliary matrixMultiplicationDefined(MatrixType left, MatrixType right) {
	left.width == right.height
}

auxiliary multipliedMatrixType(MatrixType left, MatrixType right) {
	MatrixTypeUtil.create(left.height, right.width, superType(left.actualEntryType, right.actualEntryType) as MathematicalType)
}

auxiliary superType(Type a, Type b) {
	var Type result
	{
		empty |- a <: b
		result = b
	} or {
		empty |- b <: a
		result = a
	}
	result
}

auxiliary isSquare(MatrixType type) {
	type.height == type.width
}

auxiliary consistentLineWidth(MultiLineMatrixLiteral lit) {
	val width = lit.lines.get(0).getEntries().size()
	var consistent = true
	for (line : lit.lines) {
		consistent = consistent && line.getEntries().size() == width
	}
	consistent
}

auxiliary transpose(MatrixType type) {
	MatrixTypeUtil.create(type.width, type.height, type.actualEntryType)
}

auxiliary isGeneric(String size) {
	size.charAt(0).toString() == '$'
}

auxiliary checkParamTypes(VariableRegister genReg, List<TypedVarDeclaration> declaredParams, List<Expression> suppliedParams) {
	{ (suppliedParams.size() == declaredParams.size) }

	for (i : 0 ..< suppliedParams.size) {
		empty |- suppliedParams.get(i) : var Type valueType
		empty ||- declaredParams.get(i) : var Type paramType;

		if (valueType instanceof MatrixType && paramType instanceof MatrixType && (paramType as MatrixType).isGeneric()) {
			val exactType = valueType as MatrixType;
			val generic = paramType as MatrixType
			(genericVarMatches(genReg, generic.height, exactType.height)
				&& (genericVarMatches(genReg, generic.width, exactType.width)))
			 or fail error "generic param type does not match"
				source suppliedParams.get(i)

			(!(generic.actualEntryType instanceof GenericType) || genericTypeMatches(genReg, generic.actualEntryType as GenericType, (valueType as MatrixType).actualEntryType))
			or fail error "generic param matzrix entry type does not match"
				source suppliedParams.get(i)
		} else if (paramType instanceof GenericType && valueType instanceof MathematicalType) {
			genericTypeMatches(genReg, paramType as GenericType, valueType as MathematicalType)
			or fail error "generic param type does not match"
				source suppliedParams.get(i)
		} else {
			empty |- valueType <: paramType
			or fail error "param type " + stringRep(valueType) + " does not match " + stringRep(paramType)
				source suppliedParams.get(i)
		}
	}
}

auxiliary genericVarMatches(VariableRegister genReg, String variable, String value) {
	if (isGeneric(variable)) {
		if (!genReg.exists(variable)) {
			genReg.add(variable, value, true)
			true
		} else
			(genReg.get(variable) == value)
	} else true
}

auxiliary genericTypeMatches(VariableRegister genReg, GenericType generic, MathematicalType value) {
	if (!genReg.exists(generic.name)) {
		genReg.add(generic.name, value, true)
		true
	} else {
		empty |- value <: genReg.get(generic.name) as MathematicalType
	}
}

auxiliary scalarMultType(MathematicalType scalar, MatrixType matr) {
	var MatrixType result
	{
		empty |- scalar <: matr.actualEntryType
		result = matr
	} or {
		empty |- matr.actualEntryType <: scalar
		result = MatrixTypeUtil.create(matr.height, matr.width, scalar)
	}
	result
}

/* SUBTYPING */
rule SMatrixType
	derives G |- MatrixType sub <: MatrixType sup
from {
	{ sub.dimensionsEqual(sup) }
	{ G |- sub.actualEntryType <: sup.actualEntryType }
}

rule SGenericTypes
	derives G |- GenericType sub <: GenericType sup
from {
	sub.name == sup.name
}

axiom SIntMathematical
	G |-IntegerType sub <: MathematicalType sup // integers are a subset of any number set used here

rule SDefault
	G |- Type sub <: Type sup
from {
	sub.eClass == sup.eClass
}

/* TYPING */
axiom TTypedVarDecl
	G ||- TypedVarDeclaration variable : variable.type

rule TInferredVarDecl
	G ||- InferredVarDeclaration decl : Type type
from {
	G |- decl.value : type
}

axiom TIntegerLiteral
    G |- IntLiteral expr : MatrixFactory.eINSTANCE.createIntegerType()

axiom TBooleanLiteral
	G |- BooleanLiteral bool : MatrixFactory.eINSTANCE.createBooleanType()

axiom TGenericVariable
	G |- GenericVariable gen : MatrixFactory.eINSTANCE.createIntegerType()

axiom TRationalLiteral
	G |- RationalLiteral frac : MatrixFactory.eINSTANCE.createRationalType()

rule TVariable
	G |- Variable variable : Type type
from {
	G ||- variable.ref : type
}

rule TFunctionCall
	G |- FunctionCall call : Type type
from {
	val genericRegister = new VariableRegister();
	checkParamTypes(genericRegister, call.func.ref.params.params, call.params)

	val retType = call.func.ref.returnType
	type = if (retType instanceof MatrixType) {
		if (retType.isGeneric())
			MatrixTypeUtil.create(
				if (isGeneric(retType.height)) genericRegister.get(retType.height).toString() else retType.height,
				if (isGeneric(retType.width))  genericRegister.get(retType.width).toString()  else retType.width,
				if (retType.actualEntryType instanceof GenericType)
					genericRegister.get((retType.actualEntryType as GenericType).name) as MathematicalType
				else retType.actualEntryType
			)
		else
			retType
	} else if (retType instanceof GenericType)
		genericRegister.get(retType.name) as MathematicalType
	else
		retType
}

rule TDeterminantOrAbsoluteValueExpression
	G |- DeterminantOrAbsoluteValueExpression expr : MathematicalType type
from {
	G |- expr.inner : var Type innerType

	if (innerType instanceof MatrixType) {
		{ isSquare(innerType) }
		or fail error "Matrix determinant is only defined for square matrices" source expr
		type = innerType.entryType
	} else if (innerType instanceof MathematicalType)
		type = innerType
	else {
		fail error "Cannot type determinant or absolute value of type " + stringRep(innerType) source expr
	}
}

rule TMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit : MatrixType type
from {
	(consistentLineWidth(lit))
	or fail error "matrix lines must all have the same width" source lit

	val lines = lit.lines.size()
	val columns = lit.lines.get(0).getEntries().size()
	type = MatrixTypeUtil.create(Integer.toString(lines), Integer.toString(columns), lit.entryType) // TODO: if entryType is null, derive from entries
}

rule TMatrixInit
	G |- MatrixInit init : MatrixType type
from {
	var MathematicalType entryType = init.entryType
	//if (entryType == null) // FIXME: enabling this somehow magically breaks the example code
	//	G |- init.entry : entryType // (counter var j is properly typed at first, but suddenly its type is null)
	// leading to a NullPointerException in TVariable
	type = MatrixTypeUtil.create(init.lineMax, init.colMax, entryType)
}

rule TParenthesis
	G |- ParenthesizedExpression expr : Type type
from {
	G |- expr.inner : type
}

rule TVariableAssignment
	G |- VariableAssignment assign : Type vartype
from {
	G |- assign.variable : vartype
	G |- assign.value : var Type valtype
	G |- valtype <: vartype or fail error "value cannot be assigned" source assign.value
}

rule TMatrixEntryAssignment
	G |- MatrixEntryAssignment assign : MathematicalType type
from {
	G |- assign.matr : var MatrixType matrType
	G |- assign.value : var Type valType
	G |- valType <: matrType.actualEntryType or fail error "entry cannot be assigned" source assign.value
	type = matrType.actualEntryType
}

rule TLogical
	G |- LogicalAndOr log : BooleanType bool
from {
	G |- log.left : bool
	G |- log.right : bool
}

rule TEquals
	G |- Equals eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType

	{ G |- leftType <: rightType } or { G |- rightType <: leftType }
}

rule TComparison
	G |- Comparison comp : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- comp.left : var Type leftType
	G |- comp.right : var Type rightType
	(leftType instanceof MathematicalType) && (rightType instanceof MathematicalType) // matrices and booleans cannot be compared
}

rule TEquivalency
	G |- Equivalency eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType
	(leftType instanceof MatrixType && rightType instanceof MatrixType)
	G|- leftType <: rightType
}

rule TAddition
	G |- Addition add : Type type
from  {
	G |- add.left  : var Type leftType
	G |- add.right : var Type rightType

	{
		G |- leftType <: rightType
		type = rightType
	}
	or {
		G|- rightType <: leftType
		type = leftType
	}
}

rule TDivision
	G |- Division div : MatrixFactory.eINSTANCE.createRationalType()
from {
	G |- div.left : var MathematicalType leftType
	G |- div.right : var MathematicalType rightType
}

rule TMultiplication
	G |- Multiplication mult : Type type
from {
	G |- mult.left  : var Type leftType
	G |- mult.right : var Type rightType

	if (leftType instanceof MatrixType && rightType instanceof MatrixType) { // matrix multiplication
		(matrixMultiplicationDefined(leftType as MatrixType, rightType as MatrixType))
		or fail error "Matrix multiplication is not defined"
			source mult
		type = multipliedMatrixType(leftType as MatrixType, rightType as MatrixType)
	}
	else if (leftType instanceof MatrixType) {
		(rightType instanceof MathematicalType) // right scalar multiplication
		or fail error "Scalar multiplication not defined"
			source mult
		type = scalarMultType(rightType as MathematicalType, leftType)
	}
	else if (rightType instanceof MatrixType) {
		(leftType instanceof MathematicalType) // left scalar multiplication
		or fail error "Scalar multiplication not defined"
			source mult
		type = scalarMultType(leftType as MathematicalType, rightType)
	}
	else {
		(leftType instanceof MathematicalType && rightType instanceof MathematicalType)
		or fail error "Multiplication undefined"
			source mult
		type = superType(leftType, rightType)
	}
}

rule TUnaryMinus
	G |- UnaryMinus un : Type type
from {
	G |- un.expr : type
}

rule TTransposition
	G |- Transposition t : MatrixType type
from {
	G |- t.base : var MatrixType baseType
	type = transpose(baseType)
}

rule TExponentiation
	G |- Exponentiation exp : Type baseType
from {
	G |- exp.base : baseType

	{ (baseType instanceof MathematicalType) }
	or { (baseType instanceof MatrixType && isSquare(baseType as MatrixType)) }

	G |- exp.exp : var Type expType
	(expType instanceof IntegerType)
}

rule TNegation
	G |- Negation neg : BooleanType bool
from {
	G |- neg.expr : bool
}

rule TTernary
	G |- Ternary ter : Type type
from {
	G |- ter.cond : var BooleanType bool
	G |- ter.ifTrue : var Type trueType
	G |- ter.ifFalse : var Type falseType

	{
		G |- trueType <: falseType
		type = falseType
	} or {
		G |- falseType <: trueType
		type = trueType
	} or fail error "expression doesn't have matching type" source ter.ifFalse
}

rule TEntryAccess
	G |- EntryAccess acc : MathematicalType type
from {
	var IntegerType intType
	G |- acc.matr : var MatrixType matrType
	G |- acc.line : intType
	G |- acc.column : intType
	type = matrType.actualEntryType
}