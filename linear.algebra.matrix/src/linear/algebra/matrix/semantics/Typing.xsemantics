system linear.algebra.matrix.semantics.Typing

validatorExtends linear.algebra.matrix.validation.AbstractMatrixValidator

import linear.algebra.matrix.matrix.*
import linear.algebra.matrix.interpreter.VariableRegister
import java.util.List

auxiliary {
	smartType(Type in) : Type
	genericVarMatches(VariableRegister genReg, String variable, String value) : boolean
	checkParamTypes(VariableRegister genReg, List<VarDeclaration> declaredParams, List<Expression> suppliedParams)
	genericTypeMatches(VariableRegister genReg, GenericType generic, MathematicalType value) : boolean
	isGeneric(String size) : boolean
	consistentLineWidth(MultiLineMatrixLiteral lit) : boolean
	isSquare(SmartMatrixType type) : boolean
	matrixMultiplicationDefined(SmartMatrixType left, SmartMatrixType right) : boolean
	multipliedMatrixType(SmartMatrixType left, SmartMatrixType right) : SmartMatrixType
	transpose(SmartMatrixType type) : SmartMatrixType
	superType(Type a, Type b) : Type
	scalarMultType(MathematicalType scalar, MatrixType matr) : MatrixType
}

judgments {
	type |- Expression expr : output Type
		error "Cannot type " + stringRep(expr)
		source expr
	subtype |- Type sub <: Type sup
    vartype ||- VarDeclaration decl : output Type
}

auxiliary smartType(Type in) {
	if (in instanceof MatrixType && !(in instanceof SmartMatrixType))
		SmartMatrixType.copy(in as MatrixType)
	else
		in
}

auxiliary matrixMultiplicationDefined(SmartMatrixType left, SmartMatrixType right) {
	left.width == right.height
}

auxiliary multipliedMatrixType(SmartMatrixType left, SmartMatrixType right) {
	new SmartMatrixType(left.height, right.width, superType(left.entryType, right.entryType) as MathematicalType)
}

auxiliary superType(Type a, Type b) {
	var Type result
	{
		empty |- a <: b
		result = b
	} or {
		empty |- b <: a
		result = a
	}
	result
}

auxiliary isSquare(SmartMatrixType type) {
	type.height == type.width
}

auxiliary consistentLineWidth(MultiLineMatrixLiteral lit) {
	val width = lit.lines.get(0).getEntries().size()
	var consistent = true
	for (line : lit.lines) {
		consistent = consistent && line.getEntries().size() == width
	}
	consistent
}

auxiliary transpose(SmartMatrixType type) {
	new SmartMatrixType(type.width, type.height, type.entryType)
}

auxiliary isGeneric(String size) {
	size.charAt(0).toString() == '$'
}

auxiliary checkParamTypes(VariableRegister genReg, List<VarDeclaration> declaredParams, List<Expression> suppliedParams) {
	{ (suppliedParams.size() == declaredParams.size) }

	for (i : 0 ..< suppliedParams.size) {
		empty |- suppliedParams.get(i) : var Type valueType
		empty ||- declaredParams.get(i) : var Type paramType;

		var SmartMatrixType generic;
		if (valueType instanceof MatrixType && paramType instanceof MatrixType && (generic = SmartMatrixType.copy(paramType as MatrixType)).isGeneric()) {
			val exactType = valueType as MatrixType;
			(genericVarMatches(genReg, generic.height, exactType.height)
				&& (genericVarMatches(genReg, generic.width, exactType.width)))
			 or fail error "generic param type does not match"
				source suppliedParams.get(i)

			(!(generic.entryType instanceof GenericType) || genericTypeMatches(genReg, generic.entryType as GenericType, (valueType as MatrixType).entryType))
			or fail error "generic param matzrix entry type does not match"
				source suppliedParams.get(i)
		} else if (paramType instanceof GenericType && valueType instanceof MathematicalType) {
			genericTypeMatches(genReg, paramType as GenericType, valueType as MathematicalType)
			or fail error "generic param type does not match"
				source suppliedParams.get(i)
		} else {
			empty |- valueType <: paramType
			or fail error "param type " + stringRep(valueType) + " does not match " + stringRep(paramType)
				source suppliedParams.get(i)
		}
	}
}

auxiliary genericVarMatches(VariableRegister genReg, String variable, String value) {
	if (isGeneric(variable)) {
		if (!genReg.exists(variable)) {
			genReg.add(variable, value, true)
			true
		} else
			(genReg.get(variable) == value)
	} else true
}

auxiliary genericTypeMatches(VariableRegister genReg, GenericType generic, MathematicalType value) {
	if (!genReg.exists(generic.name)) {
		genReg.add(generic.name, value, true)
		true
	} else {
		empty |- value <: genReg.get(generic.name) as MathematicalType
	}
}

auxiliary scalarMultType(MathematicalType scalar, MatrixType matr) {
	var MatrixType result
	{
		empty |- scalar <: matr.entryType
		result = matr
	} or {
		empty |- matr.entryType <: scalar
		result = new SmartMatrixType(matr.height, matr.width, scalar)
	}
	result
}

/* SUBTYPING */
rule SMatrixType
	derives G |- MatrixType sub <: MatrixType sup
from {
	val smartSub = SmartMatrixType.copy(sub)
	val smartSup = SmartMatrixType.copy(sup)

	{ smartSub.dimensionsEqual(smartSup) }
	{ G |- smartSub.entryType <: smartSup.entryType }
}

rule SGenericTypes
	derives G |- GenericType sub <: GenericType sup
from {
	sub.name == sup.name
}

axiom SIntFraction
	G |-IntegerType sub <: RationalType sup

rule SDefault
	G |- Type sub <: Type sup
from {
	sub.eClass == sup.eClass
}

/* TYPING */
rule TTypedVarDecl
	G ||- TypedVarDeclaration variable : Type type
from {
	type = smartType(variable.type) // XSemantics does not allow this in an axiom
}

rule TInferredVarDecl
	G ||- InferredVarDeclaration decl : Type type
from {
	G |- decl.value : type
}

axiom TIntegerLiteral
    G |- IntLiteral expr : MatrixFactory.eINSTANCE.createIntegerType()

axiom TBooleanLiteral
	G |- BooleanLiteral bool : MatrixFactory.eINSTANCE.createBooleanType()

axiom TGenericVariable
	G |- GenericVariable gen : MatrixFactory.eINSTANCE.createIntegerType()

axiom TRationalLiteral
	G |- RationalLiteral frac : MatrixFactory.eINSTANCE.createRationalType()

rule TVariable
	G |- Variable variable : Type type
from {
	G ||- variable.ref : type
}

rule TFunctionCall
	G |- FunctionCall call : Type type
from {
	val genericRegister = new VariableRegister();
	checkParamTypes(genericRegister, call.func.ref.params.params, call.params)

	val retType = smartType(call.func.ref.returnType)
	type = if (retType instanceof SmartMatrixType) { // after the previous line, any MatrixType goes in here
		if (retType.isGeneric())
			new SmartMatrixType(
				if (isGeneric(retType.height)) genericRegister.get(retType.height).toString() else retType.height,
				if (isGeneric(retType.width))  genericRegister.get(retType.width).toString()  else retType.width,
				if (retType.entryType instanceof GenericType)
					genericRegister.get((retType.entryType as GenericType).name) as MathematicalType
				else retType.entryType
			)
		else
			retType
	} else if (retType instanceof GenericType)
		genericRegister.get(retType.name) as MathematicalType
	else
		retType
}

rule TMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit : SmartMatrixType type
from {
	(consistentLineWidth(lit))

	val lines = lit.lines.size()
	val columns = lit.lines.get(0).getEntries().size()
	type = new SmartMatrixType(Integer.toString(lines), Integer.toString(columns), lit.entryType) // TODO: if entryType is null, derive from entries
}

rule TMatrixInit
	G |- MatrixInit init : SmartMatrixType type
from {
	var MathematicalType entryType = init.entryType
	//if (entryType == null) // FIXME: enabling this somehow magically breaks the example code
	//	G |- init.entry : entryType // (counter var j is properly typed at first, but suddenly its type is null)
	// leading to a NullPointerException in TVariable
	type = new SmartMatrixType(init.lineMax, init.colMax, entryType)
}

rule TParenthesis
	G |- ParenthesizedExpression expr : Type type
from {
	G |- expr.inner : type
}

rule TVariableAssignment
	G |- VariableAssignment assign : Type vartype
from {
	G |- assign.variable : vartype
	G |- assign.value : var Type valtype
	G |- valtype <: vartype or fail error "value cannot be assigned" source assign.value
}

rule TMatrixEntryAssignment
	G |- MatrixEntryAssignment assign : MathematicalType type
from {
	G |- assign.matr : var MatrixType matrType
	G |- assign.value : var Type valType
	G |- valType <: matrType.entryType or fail error "entry cannot be assigned" source assign.value
	type = matrType.entryType
}

rule TLogical
	G |- LogicalAndOr log : BooleanType bool
from {
	G |- log.left : bool
	G |- log.right : bool
}

rule TEquals
	G |- Equals eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType

	{ G |- leftType <: rightType } or { G |- rightType <: leftType }
}

rule TComparison
	G |- Comparison comp : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- comp.left : var Type leftType
	G |- comp.right : var Type rightType
	(leftType instanceof MathematicalType) && (rightType instanceof MathematicalType) // matrices and booleans cannot be compared
}

rule TEquivalency
	G |- Equivalency eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType
	(leftType instanceof SmartMatrixType && rightType instanceof SmartMatrixType)
	G|- leftType <: rightType
}

rule TAddition
	G |- Addition add : Type type
from  {
	G |- add.left  : var Type leftType
	G |- add.right : var Type rightType

	{
		G |- leftType <: rightType
		type = rightType
	}
	or {
		G|- rightType <: leftType
		type = leftType
	}
}

rule TDivision
	G |- Division div : MatrixFactory.eINSTANCE.createRationalType()
from {
	G |- div.left : var MathematicalType leftType
	G |- div.right : var MathematicalType rightType
}

rule TMultiplication
	G |- Multiplication mult : Type type
from {
	G |- mult.left  : var Type leftType
	G |- mult.right : var Type rightType

	if (leftType instanceof SmartMatrixType && rightType instanceof SmartMatrixType) { // matrix multiplication
		(matrixMultiplicationDefined(leftType as SmartMatrixType, rightType as SmartMatrixType))
		or fail error "Matrix multiplication is not defined"
			source mult
		type = multipliedMatrixType(leftType as SmartMatrixType, rightType as SmartMatrixType)
	}
	else if (leftType instanceof SmartMatrixType) {
		(rightType instanceof MathematicalType) // right scalar multiplication
		or fail error "Scalar multiplication not defined"
			source mult
		type = scalarMultType(rightType as MathematicalType, leftType)
	}
	else if (rightType instanceof SmartMatrixType) {
		(leftType instanceof MathematicalType) // left scalar multiplication
		or fail error "Scalar multiplication not defined"
			source mult
		type = scalarMultType(leftType as MathematicalType, rightType)
	}
	else {
		(leftType instanceof MathematicalType && rightType instanceof MathematicalType)
		or fail error "Multiplication undefined"
			source mult
		type = superType(leftType, rightType)
	}
}

rule TUnaryMinus
	G |- UnaryMinus un : Type type
from {
	G |- un.expr : type
}

rule TTransposition
	G |- Transposition t : SmartMatrixType type
from {
	G |- t.base : var SmartMatrixType baseType
	type = transpose(baseType)
}

rule TExponentiation
	G |- Exponentiation exp : Type baseType
from {
	G |- exp.base : baseType

	{ (baseType instanceof MathematicalType) }
	or { (baseType instanceof SmartMatrixType && isSquare(baseType as SmartMatrixType)) }

	G |- exp.exp : var Type expType
	(expType instanceof IntegerType)
}

rule TNegation
	G |- Negation neg : BooleanType bool
from {
	G |- neg.expr : bool
}

rule TTernary
	G |- Ternary ter : Type type
from {
	G |- ter.cond : var BooleanType bool
	G |- ter.ifTrue : var Type trueType
	G |- ter.ifFalse : var Type falseType

	{
		G |- trueType <: falseType
		type = falseType
	} or {
		G |- falseType <: trueType
		type = trueType
	} or fail error "expression doesn't have matching type" source ter.ifFalse
}

rule TEntryAccess
	G |- EntryAccess acc : MathematicalType type
from {
	var IntegerType intType
	G |- acc.matr : var SmartMatrixType matrType
	G |- acc.line : intType
	G |- acc.column : intType
	type = matrType.entryType
}