system linear.algebra.matrix.semantics.Typing
	extends linear.algebra.matrix.semantics.CommonType

import linear.algebra.matrix.matrix.*
import linear.algebra.matrix.interpreter.VariableRegister
import java.util.List

auxiliary {
	genericVarMatches(VariableRegister genReg, String variable, String value) : Boolean
	checkParamTypes(VariableRegister genReg, List<TypedVarDeclaration> declaredParams, List<Expression> suppliedParams)
	genericTypeMatches(VariableRegister genReg, GenericType generic, MathematicalType value) : Boolean
	isGeneric(String size) : Boolean
	multipliedMatrixType(MatrixType left, MatrixType right) : MatrixType
	transpose(MatrixType type) : MatrixType
	scalarMultType(MathematicalType scalar, MatrixType matr) : MatrixType
	createMatrixType(String height, String width, MathematicalType entryType) : MatrixType
	makeExactFromGeneric(VariableRegister generics, MatrixType matrType) : MatrixType
}

judgments {
	type |- Expression expr : output Type
		error "Cannot type " + stringRep(expr)
		source expr
    vartype ||- VarDeclaration decl : output Type
}

auxiliary multipliedMatrixType(MatrixType left, MatrixType right) {
	empty |- left.realEntryType ~~ right.realEntryType |> var MathematicalType superType
	createMatrixType(left.height, right.width, superType)
}

auxiliary transpose(MatrixType type) {
	createMatrixType(type.width, type.height, type.realEntryType)
}

auxiliary isGeneric(String size) {
	size.charAt(0).toString() == '$'
}

auxiliary checkParamTypes(VariableRegister genReg, List<TypedVarDeclaration> declaredParams, List<Expression> suppliedParams) {
	{ (suppliedParams.size() == declaredParams.size) }

	for (i : 0 ..< suppliedParams.size) {
		empty |- suppliedParams.get(i) : var Type valueType
		empty ||- declaredParams.get(i) : var Type paramType;

		if (valueType instanceof MatrixType && paramType instanceof MatrixType && (paramType as MatrixType).isGeneric()) {
			val exactType = valueType as MatrixType;
			val generic = paramType as MatrixType
			(genericVarMatches(genReg, generic.height, exactType.height)
				&& (genericVarMatches(genReg, generic.width, exactType.width)))
			 or fail error "generic param type does not match"
				source suppliedParams.get(i)

			(!(generic.realEntryType instanceof GenericType) || genericTypeMatches(genReg, generic.realEntryType as GenericType, (valueType as MatrixType).realEntryType))
			or fail error "generic param matrix entry type does not match"
				source suppliedParams.get(i)
		} else if (paramType instanceof GenericType && valueType instanceof MathematicalType) {
			genericTypeMatches(genReg, paramType as GenericType, valueType as MathematicalType)
			or fail error "generic param type does not match"
				source suppliedParams.get(i)
		} else {
			empty |- valueType <: paramType
			or fail error "param type " + stringRep(valueType) + " does not match " + stringRep(paramType)
				source suppliedParams.get(i)
		}
	}
}

auxiliary genericVarMatches(VariableRegister genReg, String variable, String value) {
	if (isGeneric(variable)) {
		if (!genReg.exists(variable)) {
			genReg.add(variable, value, true)
			true
		} else
			(genReg.get(variable) == value)
	} else true
}

auxiliary genericTypeMatches(VariableRegister genReg, GenericType generic, MathematicalType value) {
	if (!genReg.exists(generic.name)) {
		genReg.add(generic.name, value, true)
		true
	} else {
		empty |- value <: genReg.get(generic.name) as MathematicalType
	}
}

auxiliary scalarMultType(MathematicalType scalar, MatrixType matr) {
	var MatrixType result
	{
		empty |- scalar <: matr.realEntryType
		result = matr
	} or {
		empty |- matr.realEntryType <: scalar
		result = createMatrixType(matr.height, matr.width, scalar)
	}
	result
}

auxiliary createMatrixType(String height, String width, MathematicalType entryType) {
	val newType = MatrixFactory.eINSTANCE.createMatrixType()
	newType.height = height
	newType.width  = width
	newType.entryType = entryType
	newType
}

auxiliary makeExactFromGeneric(VariableRegister generics, MatrixType matrType) {
	createMatrixType(
		if (isGeneric(matrType.height)) generics.get(matrType.height).toString() else matrType.height,
		if (isGeneric(matrType.width))  generics.get(matrType.width).toString()  else matrType.width,
		if (matrType.realEntryType instanceof GenericType)
			generics.get((matrType.realEntryType as GenericType).name) as MathematicalType
		else matrType.realEntryType
	)
}

/* TYPING */
axiom TTypedVarDecl
	G ||- TypedVarDeclaration variable : variable.type

rule TInferredVarDecl
	G ||- InferredVarDeclaration decl : Type type
from {
	G |- decl.value : type
}

axiom TIntegerLiteral
    G |- IntLiteral expr : MatrixFactory.eINSTANCE.createIntegerType()

axiom TBooleanLiteral
	G |- BooleanLiteral bool : MatrixFactory.eINSTANCE.createBooleanType()

axiom TGenericVariable
	G |- GenericVariable gen : MatrixFactory.eINSTANCE.createIntegerType()

axiom TRationalLiteral
	G |- RationalLiteral frac : MatrixFactory.eINSTANCE.createRationalType()

axiom TRealLiteral
	G |- RealLiteral real : MatrixFactory.eINSTANCE.createRealType()

axiom TImaginaryLiteral
	G |- ImaginaryLiteral im : MatrixFactory.eINSTANCE.createComplexType()

rule TVariable
	G |- Variable variable : Type type
from {
	G ||- variable.ref : type
}

rule TFunctionCall
	G |- FunctionCall call : Type type
from {
	val genericRegister = new VariableRegister();
	checkParamTypes(genericRegister, call.func.ref.params.params, call.params)

	val retType = call.func.ref.returnType
	type = if (retType instanceof MatrixType) {
		if (retType.isGeneric())
			makeExactFromGeneric(genericRegister, retType)
		else
			retType
	} else if (retType instanceof GenericType)
		genericRegister.get(retType.name) as MathematicalType
	else
		retType
}

rule TDeterminantOrAbsoluteValue
	G |- DeterminantOrAbsoluteValue expr : MathematicalType type
from {
	G |- expr.inner : var Type innerType

	if (innerType instanceof MatrixType) {
		{ innerType.isSquare }
		or fail error "Matrix determinant is only defined for square matrices" source expr
		type = innerType.entryType
	} else if (innerType instanceof ComplexType)
		type = MatrixFactory.eINSTANCE.createRealType()
	else if (innerType instanceof MathematicalType)
		type = innerType
	else {
		fail error "Cannot type determinant or absolute value of type " + stringRep(innerType) source expr
	}
}

rule TMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit : MatrixType type
from {
	(lit.hasConsistentLineWidth)
	or fail error "matrix lines must all have the same width" source lit

	val lines = lit.lines.size()
	val columns = lit.lines.get(0).getEntries().size()
	type = createMatrixType(Integer.toString(lines), Integer.toString(columns), lit.entryType ?: MatrixFactory.eINSTANCE.createIntegerType()) // TODO: if entryType is null, derive from entries
}

rule TMatrixInit
	G |- MatrixInit init : MatrixType type
from {
	var MathematicalType entryType = init.entryType
	//if (entryType == null) // FIXME: enabling this somehow magically breaks the example code
	//	G |- init.entry : entryType // (counter var j is properly typed at first, but suddenly its type is null)
	// leading to a NullPointerException in TVariable
	type = createMatrixType(init.lineMax, init.colMax, entryType ?: MatrixFactory.eINSTANCE.createIntegerType())
}

rule TParenthesis
	G |- ParenthesizedExpression expr : Type type
from {
	G |- expr.inner : type
}

rule TVariableAssignment
	G |- VariableAssignment assign : Type vartype
from {
	G |- assign.variable : vartype
	G |- assign.value : var Type valtype
	G |- valtype <: vartype or fail error "value cannot be assigned" source assign.value
}

rule TMatrixEntryAssignment
	G |- MatrixEntryAssignment assign : MathematicalType type
from {
	G |- assign.matr : var MatrixType matrType
	G |- assign.value : var Type valType
	G |- valType <: matrType.realEntryType or fail error "entry cannot be assigned" source assign.value
	type = matrType.realEntryType
}

rule TLogical
	G |- LogicalAndOr log : BooleanType bool
from {
	G |- log.left : bool
	G |- log.right : bool
}

rule TEquals
	G |- Equals eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType

	{ G |- leftType <: rightType } or { G |- rightType <: leftType }
}

rule TComparison
	G |- Comparison comp : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- comp.left : var MathematicalType leftType
	G |- comp.right : var MathematicalType rightType
	!(leftType instanceof ComplexType) && !(rightType instanceof ComplexType) // complex numbers are not ordered
}

rule TEquivalency
	G |- Equivalency eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var MatrixType leftType
	G |- eq.right : var MatrixType rightType
	G |- leftType <: rightType
}

rule TAddition
	G |- Addition add : Type type
from  {
	G |- add.left  : var Type leftType
	G |- add.right : var Type rightType

	!(leftType instanceof BooleanType) && !(rightType instanceof BooleanType)

	{
		G |- leftType <: rightType
		type = rightType
	}
	or {
		G |- rightType <: leftType
		type = leftType
	}
}

rule TDivision
	G |- Division div : MathematicalType type
from {
	G |- div.left : var MathematicalType leftType
	G |- div.right : var MathematicalType rightType
	if (leftType instanceof ComplexType || rightType instanceof ComplexType)
		type = MatrixFactory.eINSTANCE.createComplexType()
	else if (leftType instanceof RealType || rightType instanceof RealType)
		type = MatrixFactory.eINSTANCE.createRealType()
	else
		type = MatrixFactory.eINSTANCE.createRationalType()
}

rule TMultiplication
	G |- Multiplication mult : Type type
from {
	G |- mult.left  : var Type leftType
	G |- mult.right : var Type rightType

	if (leftType instanceof MatrixType && rightType instanceof MatrixType) { // matrix multiplication
		((leftType as MatrixType).canMultiply(rightType as MatrixType))
		or fail error "Matrix multiplication is not defined"
			source mult
		type = multipliedMatrixType(leftType as MatrixType, rightType as MatrixType)
	}
	else if (leftType instanceof MatrixType) {
		(rightType instanceof MathematicalType) // right scalar multiplication
		or fail error "Scalar multiplication not defined"
			source mult
		type = scalarMultType(rightType as MathematicalType, leftType)
	}
	else if (rightType instanceof MatrixType) {
		(leftType instanceof MathematicalType) // left scalar multiplication
		or fail error "Scalar multiplication not defined"
			source mult
		type = scalarMultType(leftType as MathematicalType, rightType)
	}
	else {
		(leftType instanceof MathematicalType && rightType instanceof MathematicalType)
		or fail error "Multiplication of " + stringRep(leftType) + " and " + stringRep(rightType) + " undefined"
			source mult
		G |- leftType ~~ rightType |> type
	}
}

rule TUnaryMinus
	G |- UnaryMinus un : Type type
from {
	G |- un.expr : type
}

rule TTransposition
	G |- Transposition t : MatrixType type
from {
	G |- t.base : var MatrixType baseType
	type = transpose(baseType)
}

rule TExponentiation
	G |- Exponentiation exp : Type baseType
from {
	G |- exp.base : baseType

	{ (baseType instanceof MathematicalType) }
	or { (baseType instanceof MatrixType && (baseType as MatrixType).isSquare) }

	G |- exp.exp : var Type expType
	(expType instanceof IntegerType)
}

rule TNegation
	G |- Negation neg : BooleanType bool
from {
	G |- neg.expr : bool
}

rule TTernary
	G |- Ternary ter : Type type
from {
	G |- ter.cond : var BooleanType bool
	G |- ter.ifTrue : var Type trueType
	G |- ter.ifFalse : var Type falseType

	{
		G |- trueType <: falseType
		type = falseType
	} or {
		G |- falseType <: trueType
		type = trueType
	} or fail error "expression doesn't have matching type" source ter.ifFalse
}

rule TEntryAccess
	G |- EntryAccess acc : MathematicalType type
from {
	var IntegerType intType
	G |- acc.matr : var MatrixType matrType
	G |- acc.line : intType
	G |- acc.column : intType
	type = matrType.realEntryType
}