grammar linear.algebra.matrix.Matrix
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.algebra.linear/matrix/Matrix"

// I. General code structure
Code hidden(WHITESPACE, NEWLINE, SL_COMMENT, ML_COMMENT) :
	(imports+=Import)*
	(lines+=Line)*
;

Import :
	'import' source=ID ';'
;

Line :
	Action | FuncDeclaration | ProcDeclaration
;

Action :
	(TypedVarDeclaration ';')
	| (InferredVarDeclaration ';')
	| (VariableAssignment ';')
	| (MatrixEntryAssignment ';')
	| (FunctionCall ';')
	| ReturnStatement
	| IfElse
	| ProcCall
	| FromToLoop
	| WhileLoop // TODO: solve proc/func conflict without backtracking
;

TypedVarDeclaration :
	(const?=CONST)? type=Type name=ID (OP_ASSIGN value=Expression)?
;

InferredVarDeclaration :
	(const?=CONST)? 'var' name=ID OP_ASSIGN value=Expression
;

ReturnStatement :
	{ReturnStatement} RETURN (value=Expression)? ';'
;

ProcRef hidden() :
	ref=[ProcDeclaration|QualifiedProcName] '('
;

QualifiedProcName :
	(ID '::')? PROC_NAME
;

ProcCall :
	proc=ProcRef (params+=Expression (',' params+=Expression)*)? ')' ';'
;

FromToLoop :
	'from' var=Variable '=' init=Expression 'to' end=Expression body=Block
;

WhileLoop :
	'while' cond=Expression body=Block
;

Block: 
	{Block} '{' (lines+=Action)* '}'
;

// I. a) conditionals
IfBody :
	Action | Block
;

IfElse :
	IF '(' cond=Expression ')' ifTrue=IfBody
	(=>ELSE else=IfBody)?
;

// I. b) Function and proc declarations
FuncDeclaration :
	(internal?=INTERNAL)? DEF name=ID ':' params=ParameterList '->' returnType=Type body=Block
;

ProcDeclaration :
	(internal?=INTERNAL)? PROC name=PROC_NAME ':' params=ParameterList body=Block
;

ParameterList :
	{ParameterList} '(' (params+=TypedVarDeclaration (',' params+=TypedVarDeclaration)*)? ')'
;

// II. types
MathematicalType :
	{IntegerType} INT
	| {IntegerType} 'ℤ' '∋'
	| {RationalType} 'rational'
	| {RationalType} 'ℚ' '∋'
	| {RealType} 'real'
	| {RealType} 'ℝ' '∋'
	| {ComplexType} 'complex'
	| {ComplexType} 'ℂ' '∋'
	| {GenericType} name=GENERIC_TYPE
;

MatrixType :
	entryType=MathematicalType? '(' height=(POSITIVE_INTEGER|GENERIC_VAR) '°' width=(POSITIVE_INTEGER|GENERIC_VAR) ')'
;

Type :
	MathematicalType | {BooleanType} BOOL | MatrixType
;

// III. Expressions
// III. a) Literals
BooleanLiteral :
	value=('true'|'false')
;

IntLiteral :
	value=(POSITIVE_INTEGER | ZERO | NEGATIVE_INTEGER)
;

RationalLiteral hidden() :
	'<' numerator=(POSITIVE_INTEGER | ZERO | NEGATIVE_INTEGER) '/' denominator=(POSITIVE_INTEGER | ZERO | NEGATIVE_INTEGER) '>'
;

RealLiteral :
	value=DOUBLE
;

CoefficientLiteral :
	IntLiteral | RationalLiteral | RealLiteral
;

ImaginaryLiteral hidden() :
	coefficient=CoefficientLiteral IMAGINARY_UNIT
;

MathematicalLiteral :
	CoefficientLiteral | ImaginaryLiteral
;

// III. a) (i) Matrix literals
MatrixInit :
	'init' entryType=MathematicalType? '(' line=TypedVarDeclaration '..' lineMax=(POSITIVE_INTEGER|GENERIC_VAR) ',' column=TypedVarDeclaration '..' colMax=(POSITIVE_INTEGER|GENERIC_VAR) ')' '~>' entry=Expression
;

MultiLineMatrixLiteral hidden(WHITESPACE, SL_COMMENT, ML_COMMENT) :
	entryType=MathematicalType? dot=Dotting?
	'{' NEWLINE
		(lines+=MatrixLiteralLine)+
	'}'
;

PlaceholderEntry :
	{PlaceholderEntry} '.'
;

MatrixEntry :
	MathematicalLiteral | PlaceholderEntry
;

MatrixLiteralLine :
	entries+=MatrixEntry (','? entries+=MatrixEntry)* NEWLINE
;

Dotting :
	'(' DOT fill=Expression ')'
;

// III. b) simple expressions
GenericVariable :
	name=GENERIC_VAR
;

Variable :
	ref=[VarDeclaration]
;

Function hidden() :
	ref=[FuncDeclaration|QualifiedFunctionName] '('
;

QualifiedFunctionName :
	(ID '::')? ID
;

FunctionCall :
	func=Function (params+=Expression (',' params+=Expression)*)? ')'
;

DeterminantOrAbsoluteValue :
	'|' inner=Expression '|'
;

ParenthesizedExpression :
	'(' inner=Expression ')'
;

AtomExpression returns Expression :
	MathematicalLiteral
	| BooleanLiteral
	| MultiLineMatrixLiteral
	| MatrixInit
	| Variable
	| GenericVariable
	| ParenthesizedExpression
	| FunctionCall
	| DeterminantOrAbsoluteValue
;

// III. c) complex expressions
VariableAssignment :
	variable=Variable OP_ASSIGN value=Expression
;

MatrixEntryAssignment :
	matr=AtomExpression '[' line=Expression ',' column=Expression ']' OP_ASSIGN value=Expression
;

EntryAccess returns Expression :
	AtomExpression ({EntryAccess.matr=current} '[' line=Expression ',' column=Expression ']')*
;

Negation returns Expression :
	EntryAccess | ({Negation} ('!'|'¬') expr=EntryAccess)
;

Transposition returns Expression :
	Negation ({Transposition.base=current} '^' TRANSPOS)?
;

Exponentiation returns Expression :
	Transposition ({Exponentiation.base=current} '^' exp=Transposition)*
;

UnaryMinus returns Expression :
	Exponentiation | {UnaryMinus} ('-' expr=Exponentiation)
;

Division returns Expression :
	UnaryMinus ({Division.left=current} '/' right=UnaryMinus)*
;

Multiplication returns Expression :
	Division ({Multiplication.left=current} '*' right=Division)*
;

Addition returns Expression :
	Multiplication ({Addition.left=current} op=AdditionOp right=Multiplication)*
;

Equivalency returns Expression :
	Addition ({Equivalency.left=current} '~' right=Addition)*
;

Comparison returns Expression :
	Equivalency ({Comparison.left=current} op=ComparisonOp right=Equivalency)*
;

Equals returns Expression :
	Comparison ({Equals.left=current} op=EqualsOp right=Comparison)*
;

LogicalAndOr returns Expression:
	Equals ({LogicalAndOr.left=current} op=LogicalOp right=Equals)*
;

Ternary returns Expression :
	LogicalAndOr ({Ternary.cond=current} '?' ifTrue=Ternary ':' ifFalse=Ternary)?
;

Expression returns Expression :
	Ternary
	| VariableAssignment
	| MatrixEntryAssignment
;

// III. d) operator enums
enum AdditionOp :
	PLUS='+' | MINUS='-'
;

enum ComparisonOp :
	LESS='<' | GREATER='>' | LESSOREQUAL='<=' | LESSOREQUAL='≤' | GREATEROREQUAL='>=' | GREATEROREQUAL='≥'
;

enum LogicalOp :
	AND='&&' | AND='∧' | AND='and' | OR='||' | OR='∨' | OR='or'
;

enum EqualsOp :
	EQUALS='=' | EQUALS='==' | NOTEQUALS='!=' | NOTEQUALS='≠'
;

ID :
	ID_PATTERN | IMAGINARY_UNIT | TRANSPOS
;

// IV. terminals
terminal OP_ASSIGN : ':=';

// IV. a) keywords:
terminal IF             : 'if';
terminal ELSE           : 'else';
terminal INT            : 'int';
terminal BOOL           : 'bool' 'ean'?;
terminal RETURN         : 'return';
terminal DEF            : 'def';
terminal PROC           : 'proc';
terminal DOT            : 'dot';
terminal CONST          : 'const';
terminal TRANSPOS       : 'T';
terminal IMAGINARY_UNIT : 'i';
terminal INTERNAL       : 'internal';

// IV. b) misc 
terminal NEWLINE      : '\n';
terminal WHITESPACE   : (' '|'\t')+;
terminal ID_PATTERN   : (LETTER|'_')(LETTER|'_'|DIGIT_WITHOUT_ZERO|'0')*;
terminal GENERIC_VAR  : '$' ID_PATTERN;
terminal GENERIC_TYPE : '%' ID_PATTERN;
terminal PROC_NAME    : '@' ID_PATTERN;

terminal fragment DIGIT_WITHOUT_ZERO : '1'..'9';
terminal fragment LETTER : ('a'..'z'|'A'..'Z');

// IV. c) numbers
terminal ZERO : '0';
terminal POSITIVE_INTEGER : DIGIT_WITHOUT_ZERO (DIGIT_WITHOUT_ZERO|ZERO)*;
terminal NEGATIVE_INTEGER : '-' POSITIVE_INTEGER;

terminal DOUBLE : '-'? (DIGIT_WITHOUT_ZERO | ZERO)+ '.' (DIGIT_WITHOUT_ZERO | ZERO)+;

// IV. d) comments
terminal SL_COMMENT : '§' !('§') !(NEWLINE)* NEWLINE?;
terminal ML_COMMENT : '§§' -> '§§';
