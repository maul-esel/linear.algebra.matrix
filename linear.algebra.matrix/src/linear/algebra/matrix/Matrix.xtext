grammar linear.algebra.matrix.Matrix
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate matrix "http://www.algebra.linear/matrix/Matrix"

// I. General code structure
Code hidden(WHITESPACE, NEWLINE, SL_COMMENT, ML_COMMENT) :
	(imports+=Import)*
	(lines+=Line)*
;

Import :
	'import' source=ID ';'
;

Line :
	Action | FuncDeclaration | ProcDeclaration
;

Action :
	(VarDeclaration ';') | (Assignment ';') | (FunctionCall ';') | ReturnStatement | IfElse | ProcCall | FromToLoop | WhileLoop // TODO: solve proc/func conflict without backtracking
;

VarDeclaration :
	TypedVarDeclaration | InferredVarDeclaration
;

TypedVarDeclaration :
	(const?=CONST)? type=Type name=ID (OP_ASSIGN value=Expression)?
;

InferredVarDeclaration :
	(const?=CONST)? 'var' name=ID OP_ASSIGN value=Expression
;

ReturnStatement :
	{ReturnStatement} RETURN (value=Expression)? ';'
;

ProcRef hidden() :
	ref=[ProcDeclaration|PROC_NAME] '('
;

ProcCall :
	proc=ProcRef (params+=Expression (',' params+=Expression)*)? ')' ';'
;

FromToLoop :
	'from' var=Variable '=' init=Expression 'to' end=Expression body=Block
;

WhileLoop :
	'while' cond=Expression body=Block
;

Block: 
	{Block} '{' (lines+=Action)* '}'
;

// I. a) conditionals
IfBody :
	Action | Block
;

IfElse :
	IF '(' cond=Expression ')' ifTrue=IfBody
	(=>ELSE else=IfBody)?
;

// I. b) Function and proc declarations
FuncDeclaration :
	(internal?=INTERNAL)? DEF name=ID ':' params=ParameterList '->' returnType=Type body=Block
;

ProcDeclaration :
	(internal?=INTERNAL)? PROC name=PROC_NAME ':' params=ParameterList body=Block
;

ParameterList :
	{ParameterList} '(' (params+=VarDeclaration (',' params+=VarDeclaration)*)? ')'
;

// II. types
SimpleType :
	MathematicalType | {BooleanType} BOOL
;

MathematicalType :
	{IntegerType} INT
;

MatrixType :
	'(' height=(POSITIVE_INTEGER|GENERIC_VAR) '°' width=(POSITIVE_INTEGER|GENERIC_VAR) ')'
;

Type :
	SimpleType | MatrixType
;

// III. Expressions
// III. a) Literals
BooleanLiteral :
	value=('true'|'false')
;

IntLiteral :
	value=(POSITIVE_INTEGER | ZERO | NEGATIVE_INTEGER)
;

MathematicalLiteral :
	IntLiteral
;

SimpleLiteral :
	MathematicalLiteral | BooleanLiteral
;

// III. a) (i) Matrix literals
MatrixInit :
	'init' '(' line=TypedVarDeclaration '..' lineMax=(POSITIVE_INTEGER|GENERIC_VAR) ',' column=TypedVarDeclaration '..' colMax=(POSITIVE_INTEGER|GENERIC_VAR) ')' '~>' entry=Expression
;

MultiLineMatrixLiteral hidden(WHITESPACE, SL_COMMENT, ML_COMMENT) :
	type=MathematicalType? dot=Dotting?
	'{' NEWLINE
		(lines+=MatrixLiteralLine)+
	'}'
;

PlaceholderEntry :
	{PlaceholderEntry} '.'
;

MatrixEntry :
	MathematicalLiteral | PlaceholderEntry
;

MatrixLiteralLine :
	entries+=MatrixEntry (','? entries+=MatrixEntry)* NEWLINE
;

Dotting :
	'(' DOT fill=Expression ')'
;

// III. b) simple expressions
Variable :
	ref=[VarDeclaration]
;

Function hidden() :
	ref=[FuncDeclaration] '('
;

FunctionCall :
	func=Function (params+=Expression (',' params+=Expression)*)? ')'
;

ParenthesizedExpression :
	'(' inner=Expression ')'
;

AtomExpression returns Expression :
	SimpleLiteral | MultiLineMatrixLiteral | MatrixInit | Variable | ParenthesizedExpression | FunctionCall
;

// III. c) complex expressions
Assignment :
	VariableAssignment | MatrixEntryAssignment
;

VariableAssignment :
	variable=Variable OP_ASSIGN value=Expression
;

MatrixEntryAssignment :
	matr=AtomExpression '[' line=Expression ',' column=Expression ']' OP_ASSIGN value=Expression
;

EntryAccess returns Expression :
	AtomExpression ({EntryAccess.matr=current} '[' line=Expression ',' column=Expression ']')*
;

Negation returns Expression :
	EntryAccess | ({Negation} '!' expr=EntryAccess)
;

Exponentiation returns Expression :
	Negation ({Exponentiation.base=current} '^' exp=Negation)*
;

Transposition returns Expression :
	Exponentiation ({Transposition.base=current} '^' TRANSPOS)?
;

UnaryMinus returns Expression :
	Transposition | {UnaryMinus} ('-' expr=Transposition)
;

Division returns Expression :
	UnaryMinus ({Division.left=current} '/' right=UnaryMinus)*
;

Multiplication returns Expression :
	Division ({Multiplication.left=current} '*' right=Division)*
;

Addition returns Expression :
	Multiplication ({Addition.left=current} op=AdditionOp right=Multiplication)*
;

Equivalency returns Expression :
	Addition ({Equivalency.left=current} '~' right=Addition)*
;

Comparison returns Expression :
	Equivalency ({Comparison.left=current} op=ComparisonOp right=Equivalency)*
;

Equals returns Expression :
	Comparison ({Equals.left=current} ('='|'==') right=Comparison)*
;

LogicalAndOr returns Expression:
	Equals ({LogicalAndOr.left=current} op=LogicalOp right=Equals)*
;

Ternary returns Expression :
	LogicalAndOr ({Ternary.cond=current} '?' ifTrue=Ternary ':' ifFalse=Ternary)?
;

Expression returns Expression :
	Ternary | Assignment
;

// III. d) operator enums
enum AdditionOp :
	PLUS='+' | MINUS='-'
;

enum ComparisonOp :
	LESS='<' | GREATER='>' | LESSOREQUAL='<=' | GREATEROREQUAL='>='
;

enum LogicalOp :
	AND='&&' | AND='and' | OR='||' | OR='or'
;

// IV. terminals
terminal OP_ASSIGN : ':=';

// IV. a) keywords:
terminal IF : 'if';
terminal ELSE : 'else';
terminal INT : 'int';
terminal BOOL : 'bool' 'ean'?;
terminal RETURN : 'return';
terminal DEF : 'def';
terminal PROC : 'proc';
terminal DOT : 'dot';
terminal CONST : 'const';
terminal TRANSPOS : 'T';
terminal INTERNAL : 'internal';

// IV. b) misc 
terminal NEWLINE  : '\n';
terminal WHITESPACE : (' '|'\t')+;
terminal ID : (LETTER|'_')(LETTER|'_'|DIGIT_WITHOUT_ZERO|'0')*;
terminal GENERIC_VAR : '$' ID;
terminal PROC_NAME : '@' ID;

terminal fragment DIGIT_WITHOUT_ZERO : '1'..'9';
terminal fragment LETTER : ('a'..'z'|'A'..'Z');

// IV. c) numbers
terminal ZERO : '0';
terminal POSITIVE_INTEGER : DIGIT_WITHOUT_ZERO (DIGIT_WITHOUT_ZERO|ZERO)*;
terminal NEGATIVE_INTEGER : '-' POSITIVE_INTEGER;

// IV. d) comments
terminal SL_COMMENT : '§' !('§') !(NEWLINE)* NEWLINE?;
terminal ML_COMMENT : '§§' -> '§§';
