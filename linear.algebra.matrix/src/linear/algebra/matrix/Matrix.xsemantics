system linear.algebra.matrix.typing.XSemanticMatrix

validatorExtends linear.algebra.matrix.validation.AbstractMatrixValidator

import org.eclipse.emf.ecore.EObject
import linear.algebra.matrix.matrix.*
import linear.algebra.matrix.core.*

auxiliary {
	matrixMultiplicationDefined(SmartMatrixType left, SmartMatrixType right) : boolean
	multipliedMatrixDimensions(SmartMatrixType left, SmartMatrixType right) : SmartMatrixType
	isSquare(SmartMatrixType type) : boolean
	consistentLineWidth(MultiLineMatrixLiteral lit) : boolean
	transpose(SmartMatrixType type) : SmartMatrixType
	hasPlaceholders(MultiLineMatrixLiteral lit) : boolean
	isGenericInParamList(SmartMatrixType type, ParameterList list) : boolean
	isGeneric(String size) : boolean
}

judgments {
    type |- Expression expr : output Type
    	error "Cannot type " + stringRep(expr)
    	source expr
   	subtype |- Type sub <: Type sup
    vartype ||- VarDeclaration decl : output Type
    interpret |- EObject obj ~> output Object
}

auxiliary matrixMultiplicationDefined(SmartMatrixType left, SmartMatrixType right) {
	left.width == right.height
}
auxiliary multipliedMatrixDimensions(SmartMatrixType left, SmartMatrixType right) {
	new SmartMatrixType(left.height, right.width)
}
auxiliary isSquare(SmartMatrixType type) {
	type.height == type.width
}
auxiliary consistentLineWidth(MultiLineMatrixLiteral lit) {
	val width = lit.lines.get(0).getEntries().size()
	var consistent = true
	for (line : lit.lines) {
		consistent = consistent && line.getEntries().size() == width
	}
	consistent
}
auxiliary transpose(SmartMatrixType type) {
	new SmartMatrixType(type.width, type.height)
}
auxiliary hasPlaceholders(MultiLineMatrixLiteral lit) {
	var placeholders = false;
	for (line : lit.lines) {
		for (entry : line.entries) {
			placeholders = placeholders || (entry instanceof PlaceholderEntry)
		}
	}
	placeholders
}
auxiliary isGenericInParamList(SmartMatrixType type, ParameterList list) {
	val height = type.height
	val width = type.width

	var heightFound = !isGeneric(height) // not generic dimensions are assumed to be "found" i.e. valid
	var widthFound = !isGeneric(width)

	for (param : list.params) {
		if (param.type instanceof MatrixType) {
			val matrType = param.type as MatrixType
			heightFound = heightFound || matrType.height == height || matrType.width == height
			widthFound = widthFound || matrType.height == width || matrType.width == width
		}
	}
	widthFound && heightFound
}
auxiliary isGeneric(String size) {
	size.charAt(0).toString() == '$'
}

/* SUBTYPING */
rule SMatrixType
	derives G |- SmartMatrixType sub <: SmartMatrixType sup
from {
	sub.equals(sup) // TODO: take into account entry type subtype relation!
}

rule SDefault
	G |- Type sub <: Type sup
from {
	sub.eClass == sup.eClass
}

/* TYPING */
rule TVarDecl
	G ||- VarDeclaration variable : Type type
from {
	if (variable.type instanceof MatrixType)
		type = SmartMatrixType.copy(variable.type as MatrixType)
	else type = variable.type
}

axiom TIntegerLiteral
    G |- IntLiteral expr : MatrixFactory.eINSTANCE.createIntegerType()

axiom TBooleanLiteral
	G |- BooleanLiteral bool : MatrixFactory.eINSTANCE.createBooleanType()

axiom TVariable
	G |- Variable variable : variable.ref.type

rule TFunctionCall
	G |- FunctionCall call : Type type
from {
	if (call.func.ref.returnType instanceof MatrixType)
		type = SmartMatrixType.copy(call.func.ref.returnType as MatrixType)
	else type = call.func.ref.returnType;
}

rule TMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit : SmartMatrixType type
from {
	// TODO: take into account entry type	
	(consistentLineWidth(lit))

	val lines = lit.lines.size()
	val columns = lit.lines.get(0).getEntries().size()
	type = new SmartMatrixType(Integer.toString(lines), Integer.toString(columns))
}

rule TParenthesis
	G |- ParenthesizedExpression expr : Type type
from {
	G |- expr.inner : type
}

rule TAssignment
	G |- Assignment assign : Type vartype
from {
	G |- assign.getVar() : vartype
	G |- assign.value : var Type valtype
	G |- vartype <: valtype
}

rule TLogical
	G |- LogicalAndOr log : BooleanType bool
from {
	G |- log.left : bool
	G |- log.right : bool
}

rule TEquals
	G |- Equals eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType

	{ G |- leftType <: rightType } or { G |- rightType <: leftType }
}

rule TComparison
	G |- Comparison comp : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- comp.left : var Type leftType
	G |- comp.right : var Type rightType
	(leftType instanceof IntegerType) && (rightType instanceof IntegerType) // matrices and booleans cannot be compared
}

rule TEquivalency
	G |- Equivalency eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType
	(leftType instanceof SmartMatrixType && rightType instanceof SmartMatrixType)
	G|- leftType <: rightType
}

rule TAddition
	G |- Addition add : Type type
from  {
	G |- add.left  : var Type leftType
	G |- add.right : var Type rightType

	{ G |- leftType <: rightType } or { G|- rightType <: leftType }
	type = leftType
}

rule TDivision
	G |- Division div : Type type
from {
	G |- div.left : var Type leftType
	G |- div.right : var Type rightType

	// TODO: use fraction
	false
}

rule TMultiplication
	G |- Multiplication mult : Type type
from {
	G |- mult.left  : var Type leftType
	G |- mult.right : var Type rightType

	{
		(leftType instanceof IntegerType && rightType instanceof IntegerType)
		type = leftType
	}
	or {
		(true && leftType instanceof IntegerType) // left scalar multiplication // change for other entry types
		type = rightType
	}
	or {
		(true && rightType instanceof IntegerType) // right scalar multiplication // change for other entry types
		type = leftType
	}
	or { // matrix multiplication
		(leftType instanceof SmartMatrixType && rightType instanceof SmartMatrixType)
		(matrixMultiplicationDefined(leftType as SmartMatrixType, rightType as SmartMatrixType))
		type = multipliedMatrixDimensions(leftType as SmartMatrixType, rightType as SmartMatrixType)
	}
}

rule TUnaryMinus
	G |- UnaryMinus un : Type type
from {
	G |- un.expr : type
}

rule TTransposition
	G |- Transposition t : SmartMatrixType type
from {
	G |- t.base : var SmartMatrixType baseType
	type = transpose(baseType)
}

rule TExponentiation
	G |- Exponentiation exp : Type baseType
from {
	G |- exp.base : baseType

	{ (baseType instanceof IntegerType) }
	or { (baseType instanceof SmartMatrixType && isSquare(baseType as SmartMatrixType)) }

	G |- exp.exp : var Type expType
	(expType instanceof IntegerType)
}

rule TNegation
	G |- Negation neg : BooleanType bool
from {
	G |- neg.expr : bool
}

rule TEntryAccess
	G |- EntryAccess acc : MatrixFactory.eINSTANCE.createIntegerType() // change for other entry types
from {
	var IntegerType intType
	G |- acc.matr : var SmartMatrixType matrType
	G |- acc.line : intType
	G |- acc.column : intType
}

/* INTERPRETING */
axiom IIntegerLiteral
	G |- IntLiteral lit ~> Integer.parseInt(lit.value)

axiom IBooleanLiteral
	G |- BooleanLiteral lit ~> Boolean.parseBoolean(lit.value)

rule IMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit ~> Matrix m
from {
	G |- lit : var SmartMatrixType matrType
	if (matrType.isExact()) {
		var im = new IntegerMatrix(Integer.parseInt(matrType.height), Integer.parseInt(matrType.width)) // change for other entry types

		var i = 1;
		for (line : lit.lines) {
			var j = 1;
			for (entry : line.entries) {
				G |- (entry as IntLiteral) ~> var Integer value // change for other entry types
				im.setEntry(i, j, value)
				j = j + 1
			}
			i = i + 1
		}

		m = im;
	} else { fail error "generic matr interpretation not implemented" }
}

rule IParenthesis
	G |- ParenthesizedExpression par ~> Object o
from {
	G |- par.inner ~> o
}

rule IEntryAccess
	G |- EntryAccess acc ~> Integer entry  // change for other entry types
from {
	G |- acc.matr ~> var Matrix mat
	G |- acc.line ~> var Integer line
	G |- acc.column ~> var Integer column
}

rule INegation
	G |- Negation neg ~> Boolean bool
from {
	G |- neg.expr ~> var Boolean inner
	bool = !inner
}

rule IExponentiation
	G |- Exponentiation expr ~> Object result
from {
	G |- expr.base ~> var Object base
	G |- expr.exp ~> var Integer exp
	if (base instanceof Integer) {
		result = Math.pow(base, exp)
	} else {
		if (exp == 1) {
			result = base
		} else if (exp == 0) {
			fail error "identity not yet implemented"
		} else if (exp <= -1) {
			fail error "inverse not implemented" // TODO: (base^-1)^(|exp|)
		} else {
			fail error "matr exp not yet implemented"
			// TODO : transform into multiplication / builtin function call and evaluate it
		}
		// TODO : do all these in one go : invert if < 0 (and exp := |exp|), set result = I, loop to exp 
	}
}

rule IUnaryMinus
	G |- UnaryMinus minus ~> Object result
from {
	G |- minus.expr ~> var Object obj
	if (obj instanceof Integer) {
		result = -obj
	} else {
		fail error "matr unary minus not implemented"
	}
}

rule IMultiplication
	G |- Multiplication mult ~> Object result
from {
	fail error "mult not implemented" // TODO
}

rule IFunctionCall
	G |- FunctionCall call ~> Object result
from {
	for (i : 0..<call.params.size()) {
		G |- call.params.get(i) ~> var Object param
		// accumulate in var register
	}
	//G /* <- vars */ |- call.func.ref ~> result
	fail error "func call not implemented"
}

/* CHECKING */
checkrule CMatrixLiteral
	for MultiLineMatrixLiteral lit
from {
	empty |- lit : var Type type
	{ lit.dot != null || !hasPlaceholders(lit) }
}

checkrule CMultiplication
	for Multiplication mult
from {
	empty |- mult : var Type type
}

checkrule CEquivalency
	for Equivalency eq
from {
	empty |- eq : var Type type
}

checkrule CAddition
	for Addition add
from {
	empty |- add : var Type type
}

checkrule CTransposition
	for Transposition t
from {
	empty |- t : var Type type
}

checkrule CExponentiation
	for Exponentiation exp
from {
	empty |- exp : var Type type
}

checkrule CNegation
	for Negation neg
from {
	empty |- neg : var Type type
}

checkrule CEntryAccess
	for EntryAccess acc
from {
	empty |- acc : var Type type
}

checkrule CNoConstAssign
	for Assignment assign
from {
	(!assign.getVar.ref.const)
	or fail
		error "Cannot assign value to constant variable"
		source assign
}

checkrule CAssignment
	for Assignment assign
from {
	empty |- assign : var Type type
}

checkrule CVarDeclaration
	for VarDeclaration variable
from {
	empty ||- variable : var Type vartype

	{ (variable.value == null) }
	or {
		empty |- variable.value : var Type valtype
		empty |- vartype <: valtype
	}

	{ (!variable.const || variable.value != null) }

	//{ !(vartype instanceof MatrixType) }
	//or {}
}

checkrule CIfCondition
	for IfElse ifelse
from {
	empty |- ifelse.cond : var BooleanType type
}

checkrule CFunctionCall
	for FunctionCall call
from {
	val callParams = call.params
	val funcParams = call.func.ref.params.params;

	{ (callParams.size() == funcParams.size) }
	for (i : 0 ..< callParams.size) {
		empty |- callParams.get(i) : var Type type
		empty |- type <: funcParams.get(i).type
		or fail error "param type " + stringRep(type) + " does not match " + stringRep(funcParams.get(i).type)
			source callParams.get(i)
	}
}

checkrule CFuncDeclaration
	for FuncDeclaration func
from {
	if (func.returnType instanceof MatrixType) {
		val retType = SmartMatrixType.copy(func.returnType as MatrixType);
		if (retType.isGeneric()) {
			(isGenericInParamList(retType, func.params))
				or fail error "Generic return type " + stringRep(retType) + " is not defined"
		}
	}
}
