system linear.algebra.matrix.typing.XSemanticMatrix

validatorExtends linear.algebra.matrix.validation.AbstractMatrixValidator

import java.util.List;

import linear.algebra.matrix.matrix.*

import linear.algebra.matrix.util.VariableRegister;

import linear.algebra.matrix.core.Matrix
import linear.algebra.matrix.core.IntegerMatrix

auxiliary {
	matrixMultiplicationDefined(SmartMatrixType left, SmartMatrixType right) : boolean
	multipliedMatrixDimensions(SmartMatrixType left, SmartMatrixType right) : SmartMatrixType
	isSquare(SmartMatrixType type) : boolean
	consistentLineWidth(MultiLineMatrixLiteral lit) : boolean
	transpose(SmartMatrixType type) : SmartMatrixType
	hasPlaceholders(MultiLineMatrixLiteral lit) : boolean
	isGenericInParamList(SmartMatrixType type, ParameterList list) : boolean
	isGeneric(String size) : boolean
	genericVarMatches(VariableRegister genReg, String variable, String value) : boolean
	checkParamTypes(VariableRegister genReg, List<ParameterDeclaration> declaredParams, List<Expression> suppliedParams)
	makeExactFromGeneric(VariableRegister generics, SmartMatrixType matrType) : SmartMatrixType
}

judgments {
    type |- Expression expr : output Type
    	error "Cannot type " + stringRep(expr)
    	source expr
   	subtype |- Type sub <: Type sup
    vartype ||- VarDeclaration decl : output Type
    interpret |- Expression expr ~> output Object
}

auxiliary matrixMultiplicationDefined(SmartMatrixType left, SmartMatrixType right) {
	left.width == right.height
}
auxiliary multipliedMatrixDimensions(SmartMatrixType left, SmartMatrixType right) {
	new SmartMatrixType(left.height, right.width)
}
auxiliary isSquare(SmartMatrixType type) {
	type.height == type.width
}
auxiliary consistentLineWidth(MultiLineMatrixLiteral lit) {
	val width = lit.lines.get(0).getEntries().size()
	var consistent = true
	for (line : lit.lines) {
		consistent = consistent && line.getEntries().size() == width
	}
	consistent
}
auxiliary transpose(SmartMatrixType type) {
	new SmartMatrixType(type.width, type.height)
}
auxiliary hasPlaceholders(MultiLineMatrixLiteral lit) {
	var placeholders = false;
	for (line : lit.lines) {
		for (entry : line.entries) {
			placeholders = placeholders || (entry instanceof PlaceholderEntry)
		}
	}
	placeholders
}
auxiliary isGenericInParamList(SmartMatrixType type, ParameterList list) {
	val height = type.height
	val width = type.width

	var heightFound = !isGeneric(height) // not generic dimensions are assumed to be "found" i.e. valid
	var widthFound = !isGeneric(width)

	for (param : list.params) {
		if (param.type instanceof MatrixType) {
			val matrType = param.type as MatrixType
			heightFound = heightFound || matrType.height == height || matrType.width == height
			widthFound = widthFound || matrType.height == width || matrType.width == width
		}
	}
	widthFound && heightFound
}
auxiliary isGeneric(String size) {
	size.charAt(0).toString() == '$'
}
auxiliary genericVarMatches(VariableRegister genReg, String variable, String value) {
	if (isGeneric(variable)) {
		if (!genReg.exists(variable)) {
			genReg.add(variable, value, true)
			true
		} else
			(genReg.get(variable) == value)
	} else true
}
auxiliary checkParamTypes(VariableRegister genReg, List<ParameterDeclaration> declaredParams, List<Expression> suppliedParams) {
	{ (suppliedParams.size() == declaredParams.size) }

	for (i : 0 ..< suppliedParams.size) {
		empty |- suppliedParams.get(i) : var Type valueType
		val Type paramType = declaredParams.get(i).type;

		var SmartMatrixType generic;
		if (valueType instanceof MatrixType && paramType instanceof MatrixType && (generic = SmartMatrixType.copy(paramType as MatrixType)).isGeneric()) {
			val exactType = valueType as MatrixType;
			(genericVarMatches(genReg, generic.height, exactType.height)
				&& (genericVarMatches(genReg, generic.width, exactType.width)))
			 or fail error "generic param type does not match" source suppliedParams.get(i)
		} else {
			empty |- valueType <: paramType
			or fail error "param type " + stringRep(valueType) + " does not match " + stringRep(paramType)
				source suppliedParams.get(i)
		}
	}
}
auxiliary makeExactFromGeneric(VariableRegister generics, SmartMatrixType matrType) {
	new SmartMatrixType(
		if (isGeneric(matrType.height)) generics.get(matrType.height) as String else matrType.height,
		if (isGeneric(matrType.width)) generics.get(matrType.width) as String else matrType.width
	)
}

/* SUBTYPING */
rule SMatrixType
	derives G |- MatrixType sub <: MatrixType sup
from {
	SmartMatrixType.copy(sub).equals(sup) // TODO: take into account entry type subtype relation!
}

rule SDefault
	G |- Type sub <: Type sup
from {
	sub.eClass == sup.eClass
}

/* TYPING */
rule TTypedVarDecl
	G ||- TypedVarDeclaration variable : Type type
from {
	if (variable.type instanceof MatrixType)
		type = SmartMatrixType.copy(variable.type as MatrixType)
	else type = variable.type
}

rule TInferredVarDecl
	G ||- InferredVarDeclaration decl : Type type
from {
	G |- decl.value : type
}

axiom TIntegerLiteral
    G |- IntLiteral expr : MatrixFactory.eINSTANCE.createIntegerType()

axiom TBooleanLiteral
	G |- BooleanLiteral bool : MatrixFactory.eINSTANCE.createBooleanType()

rule TVariable
	G |- Variable variable : Type type
from {
	G ||- variable.ref : type
}

rule TFunctionCall
	G |- FunctionCall call : Type type
from {
	if (!(call.func.ref.returnType instanceof MatrixType)) {
		type = call.func.ref.returnType;
	} else {
		val retType = SmartMatrixType.copy(call.func.ref.returnType as MatrixType)
		type = retType

		val genericRegister = new VariableRegister();
		checkParamTypes(genericRegister, call.func.ref.params.params, call.params)

		if (retType.isGeneric())
			type = new SmartMatrixType(
				if (isGeneric(retType.height)) genericRegister.get(retType.height).toString() else retType.height,
				if (isGeneric(retType.width))  genericRegister.get(retType.width).toString()  else retType.width
			);
	}
}

rule TMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit : SmartMatrixType type
from {
	// TODO: take into account entry type	
	(consistentLineWidth(lit))

	val lines = lit.lines.size()
	val columns = lit.lines.get(0).getEntries().size()
	type = new SmartMatrixType(Integer.toString(lines), Integer.toString(columns))
}

rule TParenthesis
	G |- ParenthesizedExpression expr : Type type
from {
	G |- expr.inner : type
}

rule TAssignment
	G |- Assignment assign : Type vartype
from {
	G |- assign.getVar() : vartype
	G |- assign.value : var Type valtype
	G |- vartype <: valtype or fail error "value cannot be assigned" source assign.value
}

rule TLogical
	G |- LogicalAndOr log : BooleanType bool
from {
	G |- log.left : bool
	G |- log.right : bool
}

rule TEquals
	G |- Equals eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType

	{ G |- leftType <: rightType } or { G |- rightType <: leftType }
}

rule TComparison
	G |- Comparison comp : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- comp.left : var Type leftType
	G |- comp.right : var Type rightType
	(leftType instanceof IntegerType) && (rightType instanceof IntegerType) // matrices and booleans cannot be compared
}

rule TEquivalency
	G |- Equivalency eq : MatrixFactory.eINSTANCE.createBooleanType()
from {
	G |- eq.left : var Type leftType
	G |- eq.right : var Type rightType
	(leftType instanceof SmartMatrixType && rightType instanceof SmartMatrixType)
	G|- leftType <: rightType
}

rule TAddition
	G |- Addition add : Type type
from  {
	G |- add.left  : var Type leftType
	G |- add.right : var Type rightType

	{ G |- leftType <: rightType } or { G|- rightType <: leftType }
	type = leftType
}

rule TDivision
	G |- Division div : Type type
from {
	G |- div.left : var Type leftType
	G |- div.right : var Type rightType

	// TODO: use fraction
	false
}

rule TMultiplication
	G |- Multiplication mult : Type type
from {
	G |- mult.left  : var Type leftType
	G |- mult.right : var Type rightType

	{
		(leftType instanceof IntegerType && rightType instanceof IntegerType)
		type = leftType
	}
	or {
		(true && leftType instanceof IntegerType) // left scalar multiplication // change for other entry types
		type = rightType
	}
	or {
		(true && rightType instanceof IntegerType) // right scalar multiplication // change for other entry types
		type = leftType
	}
	or { // matrix multiplication
		(leftType instanceof SmartMatrixType && rightType instanceof SmartMatrixType)
		(matrixMultiplicationDefined(leftType as SmartMatrixType, rightType as SmartMatrixType))
		type = multipliedMatrixDimensions(leftType as SmartMatrixType, rightType as SmartMatrixType)
	}
}

rule TUnaryMinus
	G |- UnaryMinus un : Type type
from {
	G |- un.expr : type
}

rule TTransposition
	G |- Transposition t : SmartMatrixType type
from {
	G |- t.base : var SmartMatrixType baseType
	type = transpose(baseType)
}

rule TExponentiation
	G |- Exponentiation exp : Type baseType
from {
	G |- exp.base : baseType

	{ (baseType instanceof IntegerType) }
	or { (baseType instanceof SmartMatrixType && isSquare(baseType as SmartMatrixType)) }

	G |- exp.exp : var Type expType
	(expType instanceof IntegerType)
}

rule TNegation
	G |- Negation neg : BooleanType bool
from {
	G |- neg.expr : bool
}

rule TEntryAccess
	G |- EntryAccess acc : MatrixFactory.eINSTANCE.createIntegerType() // change for other entry types
from {
	var IntegerType intType
	G |- acc.matr : var SmartMatrixType matrType
	G |- acc.line : intType
	G |- acc.column : intType
}

/* INTERPRETING */
axiom IVariable
	G |- Variable variable ~> env(G, 'variables', VariableRegister).get(variable.ref.name)

axiom IIntegerLiteral
	G |- IntLiteral lit ~> Integer.parseInt(lit.value)

axiom IBooleanLiteral
	G |- BooleanLiteral lit ~> Boolean.parseBoolean(lit.value)

rule IAssignment
	G |- Assignment assign ~> Object value
from {
	G |- assign.value ~> value
	env(G, 'variables', VariableRegister).set(assign.getVar.ref.name, value)
}

rule IMultiLineMatrixLiteral
	G |- MultiLineMatrixLiteral lit ~> Matrix m
from {
	G |- lit : var SmartMatrixType matrType
	if (!matrType.isExact()) {
		val generics = env(G, 'generics', VariableRegister)
		matrType = makeExactFromGeneric(generics, matrType)
	}

	var im = new IntegerMatrix(Integer.parseInt(matrType.height), Integer.parseInt(matrType.width)) // change for other entry types

	var i = 1;
	for (line : lit.lines) {
		var j = 1;
		for (entry : line.entries) {
			G |- (entry as IntLiteral) ~> var Integer value // change for other entry types
			im.setEntry(i, j, value)
			j = j + 1
		}
		i = i + 1
	}

	m = im;
}

rule IParenthesis
	G |- ParenthesizedExpression par ~> Object o
from {
	G |- par.inner ~> o
}

rule IEntryAccess
	G |- EntryAccess acc ~> Integer entry  // change for other entry types
from {
	G |- acc.matr ~> var Matrix mat
	G |- acc.line ~> var Integer line
	G |- acc.column ~> var Integer column
	entry = (mat as IntegerMatrix).getEntry(line, column)
}

rule INegation
	G |- Negation neg ~> Boolean bool
from {
	G |- neg.expr ~> var Boolean inner
	bool = !inner
}

rule IExponentiation
	G |- Exponentiation expr ~> Object result
from {
	G |- expr.base ~> var Object base
	G |- expr.exp ~> var Integer exp
	if (base instanceof Integer) {
		result = Math.pow(base, exp)
	} else {
		if (exp == 1) {
			result = base
		} else if (exp == 0) {
			fail error "identity not yet implemented"
		} else if (exp <= -1) {
			fail error "inverse not implemented" // TODO: (base^-1)^(|exp|)
		} else {
			fail error "matr exp not yet implemented"
			// TODO : transform into multiplication / builtin function call and evaluate it
		}
		// TODO : do all these in one go : invert if < 0 (and exp := |exp|), set result = I, loop to exp 
	}
}

rule IUnaryMinus
	G |- UnaryMinus minus ~> Object result
from {
	G |- minus.expr ~> var Object obj
	if (obj instanceof Integer) {
		result = -obj
	} else {
		fail error "matr unary minus not implemented"
	}
}

rule IMultiplication
	G |- Multiplication mult ~> Object result
from {
	G |- mult.left ~> var Object left
	G |- mult.right ~> var Object right

	{
		(left instanceof Integer && right instanceof Integer)
		result = (left as Integer) * (right as Integer)
	} or fail error "matrix mult not implemented"
}

rule IFunctionCall
	G |- FunctionCall call ~> Object result
from {
	for (i : 0..<call.params.size()) {
		G |- call.params.get(i) ~> var Object param
		// accumulate in var register
	}
	//G /* <- vars */ |- call.func.ref ~> result
	fail error "func call not implemented"
}

/* CHECKING */
checkrule CMatrixLiteral
	for MultiLineMatrixLiteral lit
from {
	empty |- lit : var Type type
	{ lit.dot != null || !hasPlaceholders(lit) }
}

checkrule CMultiplication
	for Multiplication mult
from {
	empty |- mult : var Type type
}

checkrule CEquivalency
	for Equivalency eq
from {
	empty |- eq : var Type type
}

checkrule CAddition
	for Addition add
from {
	empty |- add : var Type type
}

checkrule CTransposition
	for Transposition t
from {
	empty |- t : var Type type
}

checkrule CExponentiation
	for Exponentiation exp
from {
	empty |- exp : var Type type
}

checkrule CNegation
	for Negation neg
from {
	empty |- neg : var Type type
}

checkrule CEntryAccess
	for EntryAccess acc
from {
	empty |- acc : var Type type
}

checkrule CNoConstAssign
	for Assignment assign
from {
	(!assign.getVar.ref.const)
	or fail
		error "Cannot assign value to constant variable"
		source assign
}

checkrule CAssignment
	for Assignment assign
from {
	empty |- assign : var Type type
}

checkrule CVarDeclaration
	for VarDeclaration variable
from {
	empty ||- variable : var Type vartype

	{ (variable.value == null) }
	or {
		empty |- variable.value : var Type valtype
		empty |- vartype <: valtype
	}

	{ (!variable.const || variable.value != null) }

	var container = variable.eContainer;
	while (container != null && !(container instanceof FuncDeclaration) && !(container instanceof ProcDeclaration))
		container = container.eContainer;

	{ !(vartype instanceof MatrixType) }
	or { !((vartype as SmartMatrixType).isGeneric()) }
	or {
		(container != null)
		(
			(container instanceof FuncDeclaration && (isGenericInParamList(vartype as SmartMatrixType, (container as FuncDeclaration).params)))
			|| (container instanceof ProcDeclaration && (isGenericInParamList(vartype as SmartMatrixType, (container as ProcDeclaration).params)))
		)
	}
}

checkrule CVarDeclarationUnique
	for VarDeclaration decl
from {
	val container = decl.eContainer
	for (other : container.eContents)
		{ !(other instanceof VarDeclaration) || ((other as VarDeclaration).name != decl.name) || (other == decl) }
		or fail error "variable names must be unique" source decl
}

checkrule CIfCondition
	for IfElse ifelse
from {
	empty |- ifelse.cond : var BooleanType type
}

checkrule CFunctionCall
	for FunctionCall call
from {
	empty |- call : var Type type
}

checkrule CFuncDeclaration
	for FuncDeclaration func
from {
	if (func.returnType instanceof MatrixType) {
		val retType = SmartMatrixType.copy(func.returnType as MatrixType);
		if (retType.isGeneric()) {
			(isGenericInParamList(retType, func.params))
				or fail error "Generic return type " + stringRep(retType) + " is not defined"
		}
	}
}

checkrule CReturnStatement // only allowed in func / proc declarations; must return correct type
	for ReturnStatement ret
from {
	var container = ret.eContainer
	while (container != null && !(container instanceof FuncDeclaration) && !(container instanceof ProcDeclaration))
		container = container.eContainer
	{ (container != null) }

	if (container instanceof FuncDeclaration) {
		{ ret.value != null }
		{
			empty |- ret.value : var Type type
			empty |- type <: (container as FuncDeclaration).returnType
				or fail error "expression type does not match function return type" source ret.value
		}
	}

	{ !(container instanceof ProcDeclaration) } or { ret.value == null }
}

checkrule CProcCall
	for ProcCall call
from {
	val genReg = new VariableRegister();
	{ call.proc.ref.params.params.size == call.params.size }
	{ checkParamTypes(genReg, call.proc.ref.params.params, call.params) }
}

checkrule CFromToLoop
	for FromToLoop loop
from {
	{ !loop.getVar.ref.const }
		or fail error "Cannot use constant as loop counter" source loop.getVar
	var IntegerType intType
	empty ||- loop.getVar.ref : intType
		or fail error "counter var must be integer" source loop.getVar
	empty |- loop.init : intType
		or fail error "initial value must be integer" source loop.init
	empty |- loop.end : intType
		or fail error "end value must be integer" source loop.end
}

checkrule CWhileLoop
	for WhileLoop loop
from {
	empty |- loop.cond : var BooleanType bool
	or fail error "condition must be boolean" source loop.cond
}
