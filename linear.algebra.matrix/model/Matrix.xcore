@Ecore(nsURI="http://www.algebra.linear/matrix/Matrix")
@GenModel(fileExtensions="mtx", forceOverwrite="true", updateClasspath="false", modelDirectory="/linear.algebra.matrix/emf-gen")
package linear.algebra.matrix.matrix

class MatrixSyntaxElement {
}

class Code extends MatrixSyntaxElement {
	contains Import[] imports
	contains Line[] lines
}

class Import extends MatrixSyntaxElement {
	String source
}

class Line extends MatrixSyntaxElement {
}

class Action extends Line , IfBody {
}

class VarDeclaration extends Action {
	boolean const
	String name
	contains Expression value
}

class TypedVarDeclaration extends VarDeclaration {
	contains Type ^type
}

class InferredVarDeclaration extends VarDeclaration {
}

class ReturnStatement extends Action {
	contains Expression value
}

class ProcRef extends MatrixSyntaxElement {
	refers ProcDeclaration ref
}

class ProcCall extends Action {
	contains ProcRef proc
	contains Expression[] params
}

class FromToLoop extends Action {
	contains Variable ^var
	contains Expression init
	contains Expression end
	contains Block body
}

class WhileLoop extends Action {
	contains Expression cond
	contains Block body
}

class Block extends IfBody {
	contains Action[] lines
}

class IfBody extends MatrixSyntaxElement {
}

class IfElse extends Action {
	contains Expression cond
	contains IfBody ifTrue
	contains IfBody ^else
}

class FuncDeclaration extends Line {
	boolean internal
	String name
	contains ParameterList params
	contains Type returnType
	contains Block body
}

class ProcDeclaration extends Line {
	boolean internal
	String name
	contains ParameterList params
	contains Block body
}

class ParameterList extends MatrixSyntaxElement {
	contains TypedVarDeclaration[] params
}

/* TYPES */
class Type extends MatrixSyntaxElement {
}

class BooleanType extends Type {
}

class MathematicalType extends Type {
	op MathematicalType copy() {
		MatrixFactory.eINSTANCE.^create(eClass) as MathematicalType
	}
}

class IntegerType extends MathematicalType {
}

class RationalType extends MathematicalType {
}

class RealType extends MathematicalType {
}

class ComplexType extends MathematicalType {
}

class GenericType extends MathematicalType {
	String name

	op MathematicalType copy() {
		val result = super.copy() as GenericType
		result.name = name
		result
	}
}

class MatrixType extends Type {
	contains MathematicalType entryType
	String height
	String width

	op MathematicalType getRealEntryType() {
		entryType = entryType ?: MatrixFactory.eINSTANCE.createIntegerType()
		entryType
	}

	op boolean hasGenericDimensions() {
		try {
			Integer.parseInt(height)
			Integer.parseInt(width)
		} catch (NumberFormatException e) {
			return true
		}
		false
	}

	op boolean hasGenericEntryType() {
		entryType instanceof GenericType
	}

	op boolean isGeneric() {
		hasGenericDimensions() || hasGenericEntryType()
	}

	op boolean dimensionsEqual(MatrixType other) {
		height.contentEquals(other.height) && width.contentEquals(other.width)
	}

	op boolean isSquare() {
		height == width
	}

	op boolean canMultiply(MatrixType right) {
		width == right.height
	}
}

class BooleanLiteral extends Expression {
	String value
}

class IntLiteral extends CoefficientLiteral {
	String value
}

class RationalLiteral extends CoefficientLiteral {
	String numerator
	String denominator
}

class RealLiteral extends CoefficientLiteral {
	String value
}

class CoefficientLiteral extends MathematicalLiteral {
}

class ImaginaryLiteral extends MathematicalLiteral {
	contains CoefficientLiteral coefficient
}

class MathematicalLiteral extends Expression , MatrixEntry {
}

class MatrixInit extends Expression {
	contains MathematicalType entryType
	contains TypedVarDeclaration line
	String lineMax
	contains TypedVarDeclaration column
	String colMax
	contains Expression entry
}

class MultiLineMatrixLiteral extends Expression {
	contains MathematicalType entryType
	contains Dotting dot
	contains MatrixLiteralLine[] lines

	op boolean hasPlaceholders() {
		lines.map [ entries ].flatten.filter(PlaceholderEntry).size > 0
	}

	op boolean hasConsistentLineWidth() {
		lines.map [ entries.size ].toSet.size == 1
	}
}

class PlaceholderEntry extends MatrixEntry {
}

class MatrixEntry extends MatrixSyntaxElement {
}

class MatrixLiteralLine extends MatrixSyntaxElement {
	contains MatrixEntry[] entries
}

class Dotting extends MatrixSyntaxElement {
	contains Expression fill
}

class GenericVariable extends Expression {
	String name
}

class Variable extends Expression {
	refers VarDeclaration ref
}

class Function extends MatrixSyntaxElement {
	refers FuncDeclaration ref
}

class FunctionCall extends Action , Expression {
	contains Function func
	contains Expression[] params
}

class Expression extends MatrixSyntaxElement {
}

class UnaryExpression extends Expression {
	contains Expression expr
}

class DeterminantOrAbsoluteValue extends UnaryExpression {
}

class ParenthesizedExpression extends UnaryExpression {
}

class Negation extends UnaryExpression {
}

class Transposition extends UnaryExpression {
}

class UnaryMinus extends UnaryExpression {
}

class BinaryExpression extends Expression {
	contains Expression left
	contains Expression right
}

class Exponentiation extends BinaryExpression {
	op Expression getBase() {
		left
	}

	op Expression getExp() {
		right
	}
}

class Division extends BinaryExpression {
}

class Multiplication extends BinaryExpression {
}

class Addition extends BinaryExpression {
	AdditionOp ^op
}

class Equivalency extends BinaryExpression {
}

class Comparison extends BinaryExpression {
	ComparisonOp ^op
}

class Equals extends BinaryExpression {
	EqualsOp ^op
}

class LogicalAndOr extends BinaryExpression {
	LogicalOp ^op
}

class Assignment extends Action , Expression {
	contains Expression value
}

class VariableAssignment extends Assignment {
	contains Variable variable
}

class MatrixEntryAssignment extends Assignment {
	contains Expression matr
	contains Expression line
	contains Expression column
}

enum AdditionOp {
	PLUS as "+"
	MINUS as "-" = 1
}

enum ComparisonOp {
	LESS as "<"
	GREATER as ">" = 1
	LESSOREQUAL as "<=" = 2
	GREATEROREQUAL as ">=" = 3
}

enum LogicalOp {
	AND as "&&"
	OR as "||" = 1
}

enum EqualsOp {
	EQUALS as "="
	NOTEQUALS as "!=" = 1
}

class EntryAccess extends Expression {
	contains Expression matr
	contains Expression line
	contains Expression column
}

class Ternary extends Expression {
	contains Expression cond
	contains Expression ifTrue
	contains Expression ifFalse
}